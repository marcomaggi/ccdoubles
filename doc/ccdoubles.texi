\input texinfo.tex
@c %**start of header
@setfilename ccdoubles.info
@settitle CCDoubles
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCDoubles

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCDoubles

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ccdoubles

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2014, 2015

@c ------------------------------------------------------------

@set GITHUB_URL                 @url{http://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BITBUCKET_URL              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DOWNLOAD_URL               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DOCUMENTATION_URL          @url{http://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}
@set VICARE_HOMEPAGE_URL        @url{http://marcomaggi.github.io/vicare.html}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a
C99 language library implementing simple routines for vectors and
matrices of @code{double} and @code{double complex} values.  The package
is distributed under the terms of the @gnu{} General Public License
(@gpl{}).

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with
Invariant Sections being ``@gnu{} Free Documentation License'' and
``@gnu{} General Public License'', no Front--Cover Texts, and no
Back--Cover Texts.  A copy of the license is included in the section
entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ccdoubles: (ccdoubles).       CCDoubles.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* types::                       Type definitions.
* scalars::                     Operations on scalar numbers.
* vectors::                     Operations on vectors.
* matrices::                    Operations on matrices.
* lapacke::                     Utilities to operate with @cblas{}
                                and @lapacke{}.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a
C99 language library implementing simple routines for vectors and
matrices of @code{double} and @code{double complex} values.  This
library is meant to be used as companion for more sophisticated
libraries such as @acronym{CBLAS} and @acronym{LAPACKE}.

@value{PACKAGE} installs the single header file @file{ccdoubles.h}.  All
the function names in the @api{} are prefixed with @code{ccdoubles_};
all the preprocessor macro names are prefixed with @code{CCDOUBLES_};
all the type names are prefixed with @code{ccdoubles_} and suffixed with
@code{_t}.

@menu
* overview linking::            Linking code with the library.
@end menu

@c page
@node overview linking
@section Linking code with the @value{PACKAGE} library


This package installs a data file for @command{pkg-config}; usage
examples:

@example
$ pkg-config ccdoubles --modversion
0.1

$ pkg-config ccdoubles --cflags
-I/usr/local/include

$ pkg-config ccdoubles --libs
-L/usr/local/lib64 -lccdoubles
@end example

When searching for the installed library with the @gnu{} Autotools, we
can:

@enumerate
@item
Install the file @file{pkg.m4} from @file{/usr/share/aclocal} into the
source tree of the package, for example under @file{meta/autoconf/}.

@item
Include @file{pkg.m4} in the template by adding the following line to
@file{acinclude.m4}:

@example
m4_include(meta/autoconf/pkg.m4)
@end example

@item
Add the following macro use to @file{configure.ac}:

@example
PKG_CHECK_MODULES([CCDOUBLES],[ccdoubles >= 0.1])
@end example

@noindent
which will set the variables @code{CCDOUBLES_LIBS} and
@code{CCDOUBLES_CFLAGS}.

@item
Make use of @code{CCDOUBLES_LIBS} and @code{CCDOUBLES_CFLAGS} in the
@file{Makefile}.
@end enumerate

Alternatively we can use the raw @gnu{} Autoconf macros:

@example
AC_CHECK_LIB([ccdoubles],[ccd_version_string],,
  [AC_MSG_FAILURE([test for CCDoubles library failed])])
AC_CHECK_HEADERS([ccdoubles.h],,
  [AC_MSG_FAILURE([test for CCDoubles header failed])])
@end example

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the
@gnu{} Autotools.  For an explanation of interface numbers as managed by
@gnu{} Libtool @xref{Libtool versioning, interface, Libtool's versioning
system, libtool, Shared library support for @gnu{}}.


@deftypefun {const char *} ccdoubles_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing
the interface version number.
@end deftypefun


@deftypefun int ccdoubles_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int ccdoubles_version_interface_revision (void)
Return an integer representing the library interface current revision
number.
@end deftypefun


@deftypefun int ccdoubles_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node types
@chapter Type definitions


The following type definitions are declared in @file{ccdoubles.h}.


@deftp {Type Definition} ccdoubles_int_result_t
An alias for @code{int * restrict}.
@end deftp


@deftp {Type Definition} ccdoubles_int_operand_t
An alias for @code{const int * restrict}.
@end deftp


@deftp {Type Definition} ccdoubles_real_result_t
An alias for @code{double * restrict}.
@end deftp


@deftp {Type Definition} ccdoubles_real_operand_t
An alias for @code{const double * restrict}.
@end deftp


@deftp {Type Definition} ccdoubles_cplx_result_t
An alias for @code{double complex * restrict}.
@end deftp


@deftp {Type Definition} ccdoubles_cplx_operand_t
An alias for @code{const double complex * restrict}.
@end deftp

@c page
@node scalars
@chapter Operations on scalar numbers


@menu
* scalars complex::             Operations on scalar complex numbers.
@end menu

@c page
@node scalars complex
@section Operations on scalar complex numbers


@menu
* scalars complex funcs::       Functions acting on scalar complex values.
* scalars complex macros::      Preprocessor macros.
@end menu

@c page
@node scalars complex funcs
@subsection Functions acting on scalar complex values


The C99 language standard library defines common operations on scalar
@code{double complex} numbers; in addition @value{PACKAGE} defines
convenience functions to perform the same.


@deftypefun {double complex} ccdoubles_cplx_mul (double complex @vari{O}, double complex @varii{O})
Even though C99 supports the multiplication operation as:

@example
#include <ccdoubles.h>

double complex  O1 = CCDOUBLES_CPLX(1.2, 3.4);
double complex  O2 = CCDOUBLES_CPLX(5.6, 7.8);
double complex  R  = O1 * O2;

printf("R = %lf%+lfi\n", creal(R), cimag(R));
@print{} R = -19.800000+28.400000i
@end example

@noindent
this function computes and returns the product between the operands.
Example:

@example
#include <ccdoubles.h>

double complex  O1 = CCDOUBLES_CPLX(1.2, 3.4);
double complex  O2 = CCDOUBLES_CPLX(5.6, 7.8);
double complex  R;

R = ccdoubles_cplx_mul(O1, O2);

printf("R = %lf%+lfi\n", creal(R), cimag(R));
@print{} R = -19.800000+28.400000i
@end example
@end deftypefun


@deftypefun {double complex} ccdoubles_cplx_div (double complex @vari{O}, double complex @varii{O})
Even though C99 supports the division operation as:

@example
#include <ccdoubles.h>

double complex  O1 = CCDOUBLES_CPLX(1.2, 3.4);
double complex  O2 = CCDOUBLES_CPLX(5.6, 7.8);
double complex  R  = O1 / O2;

printf("R = %lf%+lfi\n", creal(R), cimag(R));
@print{} R = 0.360521+0.104989i
@end example

@noindent
this function computes and returns the division between the operands.
Example:

@example
#include <ccdoubles.h>

double complex  O1 = CCDOUBLES_CPLX(1.2, 3.4);
double complex  O2 = CCDOUBLES_CPLX(5.6, 7.8);
double complex  R;

R = ccdoubles_cplx_div(O1, O2);

printf("R = %lf%+lfi\n", creal(R), cimag(R));
@print{} R = 0.360521+0.104989i
@end example
@end deftypefun


@deftypefun {double complex} ccdoubles_cplx_neg (double complex @var{O})
Even though C99 supports the negation operation as:

@example
#include <ccdoubles.h>

double complex  O = CCDOUBLES_CPLX(1.2, 3.4);
double complex  R = - O;

printf("R = %lf%+lfi\n", creal(R), cimag(R));
@print{} R = -1.200000-3.400000i
@end example

@noindent
this function computes and returns the negation of the operand.
Example:

@example
#include <ccdoubles.h>

double complex  O = CCDOUBLES_CPLX(1.2, 3.4);
double complex  R;

R = ccdoubles_cplx_neg(O);

printf("R = %lf%+lfi\n", creal(R), cimag(R));
@print{} R = -1.200000-3.400000i
@end example
@end deftypefun


@c page
@node scalars complex macros
@subsection Preprocessor macros


@deftypefn {Preprocessor Macro} {double complex} CCDOUBLES_CPLX (double @var{REAL}, double @var{IMAG})
Build and return a new @code{double complex} value.  Expands into:

@example
(((double)(@var{REAL})) + ((double)(@var{IMAG})) * _Complex_I)
@end example

@quotation
@strong{NOTE} The latest C Language Standard defines the same operation
with the preprocessor macro @code{CMPLX(@var{REAL}, @var{IMAG})}.
@end quotation
@end deftypefn


@deftypefn {Preprocessor Macro} {double complex} Z (double @var{real}, double @var{imag})
Return a new @code{double complex}.

This macro is an alias for @func{CCDOUBLES_CPLX} but it is defined only
if the header @file{ccdoubles.h} is included with the C preprocessor
symbol @code{CCDOUBLES_ENABLE_SHORT_MACROS} already defined.
@end deftypefn


@deftypefn {Preprocessor Macro} double Re (double complex @var{Z})
@deftypefnx {Preprocessor Macro} double Im (double complex @var{Z})
Return the real or imaginary part of the complex number @var{Z} by
applying the C Standard functions @cfunc{creal} or @cfunc{cimag} to it.

This macro is defined only if the header @file{ccdoubles.h} is included
with the C preprocessor symbol @code{CCDOUBLES_ENABLE_SHORT_MACROS}
already defined.
@end deftypefn


@deftypefn {Preprocessor Macro} {double *} MREF (@var{M})
Expand into a pointer to the first element of a bidimensional array:

@example
MREF(M) @expansion{} &M[0][0]
@end example

This macro is defined only if the header @file{ccdoubles.h} is included
with the C preprocessor symbol @code{CCDOUBLES_ENABLE_SHORT_MACROS}
already defined.
@end deftypefn

@c page
@node vectors
@chapter Operations on vectors


@menu
* vectors intro::               Introduction to vector operations.
* vectors real::                Operations on real--valued vectors.
* vectors cplx::                Operations on complex--valued vectors.
* vectors int::                 Operations on @code{int}--valued vectors.
@end menu

@c page
@node vectors intro
@section Introduction to vector operations


The vectors on which @value{PACKAGE} operates are meant to be contiguous
arrays of @code{double} and @code{double complex} values, defined as
follows:

@example
#include <ccdoubles.h>
#undef NSLOTS
#define NSLOTS          2

double          RV[NSLOTS] = @{ 1.2, 3.4 @};
double complex  CV[NSLOTS] = @{
  CCDOUBLES_CPLX(1.2, 3.4),
  CCDOUBLES_CPLX(5.6, 7.8)
@};
@end example

@noindent
or as follows with dynamic size (which forbids hard--coded
initialisation of slots):

@example
unsigned        nslots = 1;
double          RV[nslots];
double complex  CV[nslots];
@end example

@c ------------------------------------------------------------

@subsubheading Vectors and bidimensional arrays


The memory layout of a vector is equal to the memory layout of the data
area of a matrix with a single row defined as follows:

@example
double                  RM[1][3];
double complex          CM[1][3];
@end example

@noindent
meaning that these definitions are equivalent to:

@example
double                  RV[3];
double *                RM[1];
RM[0] = &RV[0];

double complex          CV[3];
double complex *        CM[1];
CM[0] = &CV[0];
@end example

According to a strict interpretation of the C Language Standard, the
definition of a matrix with a single column:

@example
double                  RM[3][1];
double complex          CM[3][1];
@end example

@noindent
is equivalent to the following:

@example
double                  RV0[1];
double                  RV1[1];
double                  RV2[1];
double *                RM[3];
RM[0] = &RV0[0];
RM[1] = &RV1[0];
RM[2] = &RV2[0];

double complex          CV0[1];
double complex          CV1[1];
double complex          CV2[1];
double complex *        CM[3];
CM[0] = &CV0[0];
CM[1] = &CV1[0];
CM[2] = &CV2[0];
@end example

@noindent
and there is no guarantee that the memory allocated for the arrays
@code{RVx} and @code{CVx} is contiguous; in pictures, the memory layout
is:

@example
RM
-
| -------> |---| RV0
-
| -------> |---| RV1
-
| -------> |---| RV2
-
@end example

@noindent
and there is no guarantee that it is:

@example
RM
-          -
| -------> | RV0
-          -
| -------> | RV1
-          -
| -------> | RV2
-          -
@end example

Nevertheless, it appears that the @gnu{} C Compiler generates code to
allocate a contiguous block of memory when a bidimensional array is
defined.

@c ------------------------------------------------------------

@subsubheading @value{PACKAGE} function implementation templates


All the functions have simple implementation involving an iteration over
the vector's slots using @code{restrict} pointers; examples for real
valued vectors:

@example
void
ccdoubles_real_vector_add (unsigned nslots,
                           ccdoubles_real_result_t R,
                           ccdoubles_real_operand_t O1,
                           ccdoubles_real_operand_t O2)
@{
  for (unsigned i=0; i<nslots; ++i) @{
    R[i] = O1[i] + O2[i];
  @}
@}
void
ccdoubles_real_vector_sin (unsigned nslots,
                           ccdoubles_real_result_t R,
                           ccdoubles_real_operand_t O)
@{
  for (unsigned i=0; i<nslots; ++i) @{
    R[i] = sin(O[i]);
  @}
@}
@end example

@noindent
examples for complex valued vectors:

@example
void
ccdoubles_cplx_vector_add (unsigned nslots,
                           ccdoubles_cplx_result_t R,
                           ccdoubles_cplx_operand_t O1,
                           ccdoubles_cplx_operand_t O2)
@{
  for (unsigned i=0; i<nslots; ++i) @{
    R[i] = O1[i] + O2[i];
  @}
@}
void
ccdoubles_cplx_vector_sin (unsigned nslots,
                           ccdoubles_cplx_result_t R,
                           ccdoubles_cplx_operand_t O)
@{
  for (unsigned i=0; i<nslots; ++i) @{
    R[i] = csin(O[i]);
  @}
@}
@end example

@c ------------------------------------------------------------

@subsubheading How to call @value{PACKAGE} functions


@value{PACKAGE} functions can be called as follows, see how the arrays
are passed as arguments:

@example
#include <ccdoubles.h>
#undef NSLOTS
#define NSLOTS         2

double  V[NSLOTS] = @{ 1.2, 3.4 @};
double  R[NSLOTS];

ccdoubles_real_vector_sin(NROWS, NCOLS, R, V);
@end example

@noindent
the result is stored the array referenced by @code{R}, overwriting the
old contents.

According to the C Language Standard, the arguments @code{R} and
@code{V} in the function call:

@example
ccdoubles_real_vector_sin(NROWS, NCOLS, R, V);
@end example

@noindent
are implicitly converted to @code{&R[0]} and @code{&V[0]}, pointers to
the first element of the arrays.

@c page
@node vectors real
@section Operations on real--valued vectors


@menu
* vectors real basic::          Basic real vector operations.
* vectors real arithmetic::     Arithmetic real vector operations.
* vectors real rounding::       Rounding real vector operations.
* vectors real comparison::     Comparing real vectors.
* vectors real predicates::     Inspecting real vectors.
* vectors real special::        Special real vector operations.
* vectors real explog::         Real vector exponentiation and
                                logarithms.
* vectors real trigonometric::  Trigonometric real vector operations.
* vectors real hyperbolic::     Hyperbolic real vector operations.
* vectors real subvectors::     Subvector operations.
* vectors real printing::       Printing real vectors.
@end menu

@c page
@node vectors real basic
@subsection Basic real vector operations


@deftypefun void ccdoubles_real_vector_clear (unsigned @var{nslots}, ccdoubles_real_result_t @var{vector})
Reset all the slots to @code{0.0}.
@end deftypefun


@deftypefun void ccdoubles_real_vector_set (unsigned @var{nslots}, ccdoubles_real_result_t @var{vector}, double @var{value})
Set all the slots to the given @var{value}.
@end deftypefun


@deftypefun void ccdoubles_real_vector_copy (unsigned @var{nslots}, ccdoubles_real_result_t @var{dst}, ccdoubles_real_operand_t @var{src})
Copy the slots from @var{src} to @var{dst}.
@end deftypefun

@c page
@node vectors real arithmetic
@subsection Arithmetic real vector operations


@deftypefun void ccdoubles_real_vector_add (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
@deftypefunx void ccdoubles_real_vector_sub (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
@deftypefunx void ccdoubles_real_vector_mul (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
@deftypefunx void ccdoubles_real_vector_div (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
Perform slot--by--slot addition, subtraction, multiplication and
division.
@end deftypefun


@deftypefun void ccdoubles_real_vector_neg (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Perform the slot--by--slot negation of the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_abs (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Compute slot--by--slot the absolute value of the operand.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void ccdoubles_real_vector_fmod (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
Apply slot--by--slot the function @cfunc{fmod} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_vector_drem (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
Apply slot--by--slot the function @cfunc{drem} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_vector_remainder (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_result_t1 @varii{O})
Apply slot--by--slot the function @cfunc{remainder} to the operands.
@end deftypefun

@c page
@node vectors real rounding
@subsection Rounding real vector operations


@deftypefun void ccdoubles_real_vector_ceil (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{ceil}.
@end deftypefun


@deftypefun void ccdoubles_real_vector_floor (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{floor}.
@end deftypefun


@deftypefun void ccdoubles_real_vector_trunc (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{trunc}.
@end deftypefun


@deftypefun void ccdoubles_real_vector_round (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{round}.
@end deftypefun


@deftypefun void ccdoubles_real_vector_rint (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{rint}.
@end deftypefun

@c page
@node vectors real comparison
@subsection Comparing real vectors


@deftypefun void ccdoubles_real_vector_isgreater (unsigned @var{nslots}, ccdoubles_int_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
Apply slot--by--slot the function @cfunc{isgreater} to the operands.
Usage template:

@example
#include <ccdoubles.h>
#define NSLOTS  3

int     R[NSLOTS];
double  O1[NSLOTS];
double  O2[NSLOTS];

ccdoubles_real_vector_isgreater (NSLOTS, R, O1, O2);
@end example
@end deftypefun


@deftypefun void ccdoubles_real_vector_isgreaterequal (unsigned @var{nslots}, ccdoubles_int_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
Apply slot--by--slot the function @cfunc{isgreaterequal} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_vector_isless (unsigned @var{nslots}, ccdoubles_int_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
Apply slot--by--slot the function @cfunc{isless} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_vector_islessequal (unsigned @var{nslots}, ccdoubles_int_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
Apply slot--by--slot the function @cfunc{islessequal} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_vector_islessgreater (unsigned @var{nslots}, ccdoubles_int_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
Apply slot--by--slot the function @cfunc{islessgreater} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_vector_isunordered (unsigned @var{nslots}, ccdoubles_int_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
Apply slot--by--slot the function @cfunc{isunordered} to the operands.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void ccdoubles_real_vector_min (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
Apply slot--by--slot the function @cfunc{fmin} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_vector_max (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
Apply slot--by--slot the function @cfunc{fmax} to the operands.
@end deftypefun

@c page
@node vectors real predicates
@subsection Inspecting real vectors


@deftypefun void ccdoubles_real_vector_fpclassify (unsigned @var{nslots}, ccdoubles_int_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the macro @cfunc{fpclassify} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_isfinite (unsigned @var{nslots}, ccdoubles_int_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the macro @cfunc{isfinite} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_isinfinite (unsigned @var{nslots}, ccdoubles_int_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the macro @cfunc{isinfinite} to the operand and
reverse the result.
@end deftypefun


@deftypefun void ccdoubles_real_vector_isnormal (unsigned @var{nslots}, ccdoubles_int_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the macro @cfunc{isnormal} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_isnan (unsigned @var{nslots}, ccdoubles_int_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the macro @cfunc{isnan} to the operand.
@end deftypefun

@c page
@node vectors real special
@subsection Special real vector operations


@deftypefun double ccdoubles_real_vector_scalar_product (unsigned @var{nslots}, const ccdoubles_real_operand_t @vari{O}, const ccdoubles_real_operand_t @varii{O})
Perform the scalar product between the operands and return the result.
The implementation is:

@example
double        result = 0.0;
for (unsigned i=0; i<nslots; ++i) @{
  result += O1[i] * O2[i];
@}
return result;
@end example
@end deftypefun


@deftypefun void ccdoubles_real_vector_scalar_mul (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, double @var{lambda}, const ccdoubles_real_operand_t @var{O})
Multiply the scalar @var{lambda} with all the slots in the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_linear_combination (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, double @var{alpha}, ccdoubles_real_operand_t @vari{O}, double @var{beta}, ccdoubles_real_operand_t @varii{O})
Perform the linear combination of the vector operands and the given
scalars.  The implementation is:

@example
for (unsigned i=0; i<nslots; ++i) @{
  result[i] = alpha * O1[i] + beta * O2[i];
@}
@end example
@end deftypefun


@deftypefun void ccdoubles_real_vector_linspace (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, double @var{start}, double @var{past})
Fill the result vector with @var{nslots} evenly--spaced steps from
@var{start} to @var{past}.  It is implemented as follows:

@example
double        step = (past - start) / ((double)nslots);
for (unsigned i=0; i<nslots; ++i) @{
  result[i] = ((double)i) * step + start;
@}
@end example

As example, the code:

@example
unsigned    nslots = 10;
double      R[nslots];
double      start = 0.0;
double      past  = 10.0;
ccdoubles_real_vector_linspace (nslots, R, start, past);
ccdoubles_real_vector_print_brackets(stdout, nslots, R);
@end example

@noindent
prints (edited to add newlines):

@example
[+0.000000 +1.000000 +2.000000 +3.000000
 +4.000000 +5.000000 +6.000000 +7.000000
 +8.000000 +9.000000]
@end example
@end deftypefun


@deftypefun void ccdoubles_real_vector_logspace (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, double @var{start}, double @var{past})
Fill the result vector with @var{nslots} logarithmically spaced steps
from @code{pow(10.0, @var{start})} to @code{pow(10.0, @var{past})}.  It
is implemented as follows:

@example
double        step = (past - start) / ((double)nslots);
for (unsigned i=0; i<nslots; ++i) @{
  result[i] = pow(10.0, ((double)i) * step + start);
@}
@end example

As example, the code:

@example
unsigned    nslots = 10;
double      R[nslots];
double      start = 0.0;
double      past  = 10.0;
ccdoubles_real_vector_logspace (nslots, R, start, past);
ccdoubles_real_vector_print_brackets(stdout, nslots, R);
@end example

@noindent
prints (edited to add newlines):

@example
[+1.000000
 +10.000000
 +100.000000
 +1000.000000
 +10000.000000
 +100000.000000
 +1000000.000000
 +10000000.000000
 +100000000.000000
 +1000000000.000000]
@end example
@end deftypefun

@c page
@node vectors real explog
@subsection Real vectors exponentiation and logarithms


@deftypefun void ccdoubles_real_vector_exp (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{exp} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_exp10 (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @code{exp(X * log(10))} to the
operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_exp2 (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{exp2} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_log (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{log} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_log10 (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{log10} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_log2 (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{log2} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_logb (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{logb} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_pow (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
Apply slot--by--slot the function @cfunc{pow} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_sqrt (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{sqrt} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_cbrt (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{cbrt} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_hypot (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
Apply slot--by--slot the function @cfunc{hypot} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_expm1 (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{expm1} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_log1p (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{log1p} to the operand.
@end deftypefun

@c page
@node vectors real trigonometric
@subsection Trigonometric real vector operations


@deftypefun void ccdoubles_real_vector_sin (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
@deftypefunx void ccdoubles_real_vector_cos (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
@deftypefunx void ccdoubles_real_vector_tan (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Compute slot--by--slot the trigonometric sine, cosine, tangent of the
operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_asin (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
@deftypefunx void ccdoubles_real_vector_acos (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
@deftypefunx void ccdoubles_real_vector_atan (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Compute slot--by--slot the trigonometric arc sine, arc cosine, arc
tangent of the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_atan2 (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
Compute slot--by--slot the trigonometric arc tangent of the operands.
The implementation is:

@example
for (unsigned i=0; i<nslots; ++i) @{
  R[i] = atan2(O1[i], O2[i]);
@}
@end example

@glibcref{Inverse Trig Functions, atan2} for details on @cfunc{atan2}.
@end deftypefun

@c page
@node vectors real hyperbolic
@subsection Hyperbolic real vector operations


@deftypefun void ccdoubles_real_vector_sinh (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
@deftypefunx void ccdoubles_real_vector_cosh (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
@deftypefunx void ccdoubles_real_vector_tanh (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Compute slot--by--slot the hyperbolic sine, cosine, tangent of the
operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_asinh (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
@deftypefunx void ccdoubles_real_vector_acosh (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
@deftypefunx void ccdoubles_real_vector_atanh (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Compute slot--by--slot the hyperbolic arc sine, arc cosine, arc tangent
of the operand.
@end deftypefun

@c page
@node vectors real subvectors
@subsection Subvector operations


@deftypefun void ccdoubles_real_vector_copy_forward (unsigned @var{dst_start}, unsigned @var{src_start}, unsigned @var{nslots}, ccdoubles_real_result_t @var{dst}, ccdoubles_real_operand_t @var{src})
Copy the region of @var{nslots} values from @var{src} to @var{dst},
beginning at indexes @var{dst_start} and @var{src_start}.  The copy
happens forwards: starting with the slots at indexes @var{dst_start} and
@var{src_start}; then indexes @code{@var{dst_start} + 1} and
@code{@var{src_start} + 1}; and so on.
@end deftypefun


@deftypefun void ccdoubles_real_vector_copy_backward (unsigned @var{dst_start}, unsigned @var{src_start}, unsigned @var{nslots}, ccdoubles_real_result_t @var{dst}, ccdoubles_real_operand_t @var{src})
Copy the region of @var{nslots} values from @var{src} to @var{dst},
beginning at indexes @var{dst_start} and @var{src_start}.  The copy
happens backwards: starting with the slots at indexes
@code{@var{dst_start} + @var{nslots} - 1} and @code{@var{src_start} +
@var{nslots} - 1}; then indexes @code{@var{dst_start} + @var{nslots} -
2} and @code{@var{src_start} + @var{nslots} - 2}; and so on.
@end deftypefun

@c page
@node vectors real printing
@subsection Printing real vectors


@deftypefun void ccdoubles_real_vector_print_display (FILE * @var{f}, const char * @var{name}, unsigned @var{nslots}, ccdoubles_real_operand_t @var{O})
Print on @var{f} a layout of the operand.  @var{name} must be a pointer
to an @asciiz{} string representing the operand name.  Example:

@example
#undef NSLOTS
#define NSLOTS          3
double      O[NSLOTS] = @{ 1.1, 1.2, 1.3 @};
ccdoubles_real_vector_print_display(stdout, "O", NSLOTS, O);
@end example

@noindent
will print:

@smallexample
Vector O (dimension 3):
| (1) +1.100000 ; (2) +1.200000 ; (3) +1.300000 |
@end smallexample
@end deftypefun


@deftypefun void ccdoubles_real_vector_print_brackets (FILE * @var{f}, unsigned @var{nslots}, ccdoubles_real_operand_t @var{O})
Print on @var{f} a layout of the operand.  Example:

@example
#undef NSLOTS
#define NSLOTS          3
double      O[NSLOTS] = @{ 1.1, 1.2, 1.3 @};
ccdoubles_real_vector_print_brackets(stdout, NSLOTS, O);
@end example

@noindent
will print:

@smallexample
[+1.100000 +1.200000 +1.300000]
@end smallexample
@end deftypefun


@deftypefun void ccdoubles_real_vector_print_braces (FILE * @var{f}, unsigned @var{nslots}, ccdoubles_real_operand_t @var{O})
Print on @var{f} a layout of the operand.  Example:

@example
#undef NSLOTS
#define NSLOTS          3
double      O[NSLOTS] = @{ 1.1, 1.2, 1.3 @};
ccdoubles_real_vector_print_brackets(stdout, NSLOTS, O);
@end example

@noindent
will print:

@smallexample
@{+1.100000, +1.200000, +1.300000@}
@end smallexample
@end deftypefun

@c page
@node vectors cplx
@section Operations on complex--valued vectors


@menu
* vectors cplx basic::          Basic complex vector operations.
* vectors cplx arithmetic::     Arithmetic complex vector operations.
* vectors cplx special::        Special complex vector operations.
* vectors cplx explog::         Complex vectors exponentiation and
                                logarithms.
* vectors cplx trigonometric::  Trigonometric complex vector operations.
* vectors cplx hyperbolic::     Hyperbolic complex vector operations.
* vectors cplx subvectors::     Subvector operations.
* vectors cplx printing::       Printing complex vectors.
@end menu

@c page
@node vectors cplx basic
@subsection Basic complex vector operations


@deftypefun void ccdoubles_cplx_vector_clear (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{vector})
Reset all the slots to complex numbers with real part @code{0.0} and
complex part @code{0.0}.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_set (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{vector}, double complex @var{value})
Set all the slots to the given @var{value}.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_set_split (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{vector}, double @var{value_re}, double @var{value_im})
Set all the slots to a complex number having @var{value_re} as real part
and @var{value_im} as imaginary part.  This function is like
@cfunc{ccdoubles_cplx_vector_set}, but splitting the real and imaginary
parts makes it easier to interface it with foreign languages.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_copy (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{dst}, ccdoubles_cplx_result_t @var{src})
Copy the slots from @var{src} to @var{dst}.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void ccdoubles_cplx_vector_real (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
Extract slot--by--slot the real part of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_imag (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
Extract slot--by--slot the imaginary part of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_magnitude (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
Extract slot--by--slot the magnitude of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_angle (unsigned @var{nslots}, ccdoubles_real_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
Extract slot--by--slot the angle of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_conj (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
Compute slot--by--slot the conjugate of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_from_rect (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{R}, ccdoubles_real_result_t @var{real}, ccdoubles_real_result_t imag)
Build slot--by--slot a complex valued vectors from the real and
imaginary parts.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_from_polar (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{R}, ccdoubles_real_result_t @var{magnitude}, ccdoubles_real_result_t @var{angle})
Build slot--by--slot a complex valued vectors from the magnitude and
angle.
@end deftypefun

@c page
@node vectors cplx arithmetic
@subsection Arithmetic complex vector operations


@deftypefun void ccdoubles_cplx_vector_add (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @vari{O}, ccdoubles_cplx_operand_t @varii{O})
@deftypefunx void ccdoubles_cplx_vector_sub (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @vari{O}, ccdoubles_cplx_operand_t @varii{O})
@deftypefunx void ccdoubles_cplx_vector_mul (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @vari{O}, ccdoubles_cplx_operand_t @varii{O})
@deftypefunx void ccdoubles_cplx_vector_div (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @vari{O}, ccdoubles_cplx_operand_t @varii{O})
Perform slot--by--slot addition, subtraction, multiplication and
division.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_neg (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
Perform the slot--by--slot negation of the operand.
@end deftypefun

@c page
@node vectors cplx special
@subsection Special complex vector operations


@deftypefun {double complex} ccdoubles_cplx_vector_scalar_product (unsigned @var{nslots}, const ccdoubles_cplx_operand_t @vari{O}, const ccdoubles_cplx_operand_t @varii{O})
Perform the scalar product between the operands and return the result.
The implementation is:

@example
double complex  result = CCDOUBLES_CPLX(0.0, 0.0);
for (unsigned i=0; i<nslots; ++i) @{
  result += O1[i] * O2[i];
@}
return result;
@end example

@strong{NOTE} Whenever possible: rather than this function we should use
the function @cfunc{cblas_zdotu} (which computes the scalar product
@code{@var{R} = @vari{O}^T @varii{O}} where the first operand is
transposed) or the function @cfunc{cblas_zdotu} (which computes the
scalar product @code{@var{R} = @vari{O}^H @varii{O}} where the first
operand is conjugate--transposed).
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_scalar_product_split (unsigned @var{nslots}, ccdoubles_cplx_result_t result, const ccdoubles_cplx_operand_t @vari{O}, const ccdoubles_cplx_operand_t @varii{O})
Perform the scalar product between the operands and store the result in
the variable referenced by @var{R}.  This function is like
@cfunc{ccdoubles_cplx_vector_scalar_product}, but supplying a result
buffer makes it easier to interface it with foreign languages.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_scalar_mul (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{R}, double complex @var{lambda}, const ccdoubles_cplx_operand_t @var{O})
Multiply the scalar @var{lambda} with all the slots in the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_scalar_mul_split (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{R}, double @var{lambda_re}, double @var{lambda_im}, const ccdoubles_cplx_operand_t @var{O})
Multiply the scalar having real part @var{lambda_re} and imaginary part
@var{lambda_im} with all the slots in the operand.  This function is
like @cfunc{ccdoubles_cplx_vector_scalar_mul}, but splitting the real
and imaginary parts makes it easier to interface it with foreign
languages.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_linear_combination (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{R}, double complex @var{alpha}, ccdoubles_cplx_operand_t @vari{O}, double complex @var{beta}, ccdoubles_cplx_operand_t @varii{O})
Perform the linear combination of the vector operands and the given
scalars.  The implementation is:

@example
for (unsigned i=0; i<nslots; ++i) @{
  R[i] = alpha * O1[i] + beta * O2[i];
@}
@end example
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_linear_combination_split (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{R}, double @var{alpha_re}, double @var{alpha_im}, ccdoubles_cplx_operand_t @vari{O}, double @var{beta_re}, double @var{beta_im}, ccdoubles_cplx_operand_t @varii{O})
Perform the linear combination of the vector operands and the given
scalars.  This function is like
@cfunc{ccdoubles_cplx_vector_linear_combination}, but splitting the real
and imaginary parts of the coefficients makes it easier to interface it
with foreign languages.
@end deftypefun

@c page
@node vectors cplx explog
@subsection Complex vectors exponentiation and logarithms


@deftypefun void ccdoubles_cplx_vector_exp (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
Apply slot--by--slot the function @cfunc{cexp} to the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_log (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
Apply slot--by--slot the function @cfunc{clog} to the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_log10 (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
Apply slot--by--slot the function @cfunc{log10(cabs(Z)) + I * carg(Z)}
to the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_sqrt (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
Apply slot--by--slot the function @cfunc{csqrt} to the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_pow (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @vari{O}, ccdoubles_cplx_operand_t @varii{O})
Apply slot--by--slot the function @cfunc{cpow} to the operands.
@end deftypefun

@c page
@node vectors cplx trigonometric
@subsection Trigonometric complex vector operations


@deftypefun void ccdoubles_cplx_vector_sin (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
@deftypefunx void ccdoubles_cplx_vector_cos (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
@deftypefunx void ccdoubles_cplx_vector_tan (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
Compute slot--by--slot the trigonometric sine, cosine, tangent of the
operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_asin (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
@deftypefunx void ccdoubles_cplx_vector_acos (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
@deftypefunx void ccdoubles_cplx_vector_atan (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
Compute slot--by--slot the trigonometric arc sine, arc cosine, arc
tangent of the operand.
@end deftypefun

@c page
@node vectors cplx hyperbolic
@subsection Hyperbolic complex vector operations


@deftypefun void ccdoubles_cplx_vector_sinh (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
@deftypefunx void ccdoubles_cplx_vector_cosh (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
@deftypefunx void ccdoubles_cplx_vector_tanh (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
Compute slot--by--slot the hyperbolic sine, cosine, tangent of the
operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_asinh (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
@deftypefunx void ccdoubles_cplx_vector_acosh (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
@deftypefunx void ccdoubles_cplx_vector_atanh (unsigned @var{nslots}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
Compute slot--by--slot the hyperbolic arc sine, arc cosine, arc tangent
of the operand.
@end deftypefun

@c page
@node vectors cplx subvectors
@subsection Subvector operations


@deftypefun void ccdoubles_cplx_vector_copy_forward (unsigned @var{dst_start}, unsigned @var{src_start}, unsigned @var{nslots}, ccdoubles_cplx_result_t @var{dst}, ccdoubles_cplx_operand_t @var{src})
Copy the region of @var{nslots} values from @var{src} to @var{dst},
beginning at indexes @var{dst_start} and @var{src_start}.  The copy
happens forwards: starting with the slots at indexes @var{dst_start} and
@var{src_start}; then indexes @code{@var{dst_start} + 1} and
@code{@var{src_start} + 1}; and so on.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_copy_backward (unsigned @var{dst_start}, unsigned @var{src_start}, unsigned @var{nslots}, ccdoubles_cplx_result_t @var{dst}, ccdoubles_cplx_operand_t @var{src})
Copy the region of @var{nslots} values from @var{src} to @var{dst},
beginning at indexes @var{dst_start} and @var{src_start}.  The copy
happens backwards: starting with the slots at indexes
@code{@var{dst_start} + @var{nslots} - 1} and @code{@var{src_start} +
@var{nslots} - 1}; then indexes @code{@var{dst_start} + @var{nslots} -
2} and @code{@var{src_start} + @var{nslots} - 2}; and so on.
@end deftypefun

@c page
@node vectors cplx printing
@subsection Printing cplx vectors


@deftypefun void ccdoubles_cplx_vector_print_display (FILE * @var{f}, const char * @var{name}, unsigned @var{nslots}, ccdoubles_cplx_operand_t @var{O})
Print on @var{f} a layout of the operand.  @var{name} must be a pointer
to an @asciiz{} string representing the operand name.  Example:

@example
#define CPLX(REAL,IMAG) (CCDOUBLES_CPLX((REAL),(IMAG)))
#undef NSLOTS
#define NSLOTS          3
double complex	O[NSLOTS] = @{
  CPLX(1.1,-1.1), CPLX(1.2,-1.2), CPLX(1.3,-1.3)
@};
ccdoubles_cplx_vector_print_display(stdout, "O", NSLOTS, O);
@end example

@noindent
will print:

@smallexample
Vector O (dimension 3):
| (1) +1.100000-1.100000i ; (2) +1.200000-1.200000i ; (3) +1.300000-1.300000i |
@end smallexample
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_print_brackets (FILE * @var{f}, unsigned @var{nslots}, ccdoubles_cplx_operand_t @var{O})
Print on @var{f} a layout of the operand.  Example:

@example
#define CPLX(REAL,IMAG) (CCDOUBLES_CPLX((REAL),(IMAG)))
#undef NSLOTS
#define NSLOTS          3
double complex      O[NSLOTS] = @{
  CPLX(1.1,-1.1), CPLX(1.2,-1.2), CPLX(1.3,-1.3)
@};
ccdoubles_cplx_vector_print_brackets(stdout, NSLOTS, O);
@end example

@noindent
will print:

@smallexample
[+1.100000-1.100000i +1.200000-1.200000i +1.300000-1.300000i]
@end smallexample
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_print_braces (FILE * @var{f}, unsigned @var{nslots}, ccdoubles_cplx_operand_t @var{O})
Print on @var{f} a layout of the operand.  Example:

@example
#define CPLX(REAL,IMAG) (CCDOUBLES_CPLX((REAL),(IMAG)))
#undef NSLOTS
#define NSLOTS          3
double complex      O[NSLOTS] = @{
  CPLX(1.1,-1.1), CPLX(1.2,-1.2), CPLX(1.3,-1.3)
@};
ccdoubles_cplx_vector_print_braces(stdout, NSLOTS, O);
@end example

@noindent
will print:

@smallexample
@{+1.100000-1.100000i, +1.200000-1.200000i, +1.300000-1.300000i@}
@end smallexample
@end deftypefun

@c page
@node vectors int
@section Operations on @code{int}--valued vectors


Vectors of integer numbers are useful because some predicate functions
acting on vectors of @code{double} store the result in an array
integers.

@menu
* vectors int basic::          Basic @code{int} vector operations.
* vectors int printing::       Printing @code{int} vectors.
@end menu

@c page
@node vectors int basic
@subsection Basic @code{int} vector operations


@deftypefun void ccdoubles_int_vector_clear (unsigned @var{nslots}, ccdoubles_int_result_t @var{vector})
Reset all the slots to @code{0}.
@end deftypefun


@deftypefun void ccdoubles_int_vector_set (unsigned @var{nslots}, ccdoubles_int_result_t @var{vector}, double @var{value})
Set all the slots to the given @var{value}.
@end deftypefun


@deftypefun void ccdoubles_int_vector_copy (unsigned @var{nslots}, ccdoubles_int_result_t @var{dst}, ccdoubles_int_operand_t @var{src})
Copy the slots from @var{src} to @var{dst}.
@end deftypefun

@c page
@node vectors int printing
@subsection Printing @code{int} vectors


@deftypefun void ccdoubles_int_vector_print_display (FILE * @var{f}, const char * @var{name}, unsigned @var{nslots}, ccdoubles_int_operand_t @var{O})
Print on @var{f} a layout of the operand.  @var{name} must be a pointer
to an @asciiz{} string representing the operand name.  Example:

@example
#undef NSLOTS
#define NSLOTS          3
int     O[NSLOTS] = @{ 11, 22, 33 @};
ccdoubles_int_vector_print_display(stdout, "O", NSLOTS, O);
@end example

@noindent
will print:

@smallexample
Vector O (dimension 3):
| (1) +11 ; (2) +22 ; (3) +33 |
@end smallexample
@end deftypefun


@deftypefun void ccdoubles_int_vector_print_brackets (FILE * @var{f}, unsigned @var{nslots}, ccdoubles_int_operand_t @var{O})
Print on @var{f} a layout of the operand.  Example:

@example
#undef NSLOTS
#define NSLOTS          3
int     O[NSLOTS] = @{ 11, 22, 33 @};
ccdoubles_int_vector_print_brackets(stdout, NSLOTS, O);
@end example

@noindent
will print:

@smallexample
[+11 +22 +33]
@end smallexample
@end deftypefun


@deftypefun void ccdoubles_int_vector_print_braces (FILE * @var{f}, unsigned @var{nslots}, ccdoubles_int_operand_t @var{O})
Print on @var{f} a layout of the operand.  Example:

@example
#undef NSLOTS
#define NSLOTS          3
int      O[NSLOTS] = @{ 11, 22, 33 @};
ccdoubles_int_vector_print_brackets(stdout, NSLOTS, O);
@end example

@noindent
will print:

@smallexample
@{+11, +22, +33@}
@end smallexample
@end deftypefun

@c page
@node matrices
@chapter Operations on matrices


@menu
* matrices intro::               Introduction to matrix operations.
* matrices real::                Operations on real--valued matrices.
* matrices cplx::                Operations on complex--valued matrices.
* matrices int::                 Operations on @code{int}--valued matrices.
@end menu

@c page
@node matrices intro
@section Introduction to matrix operations


The matrices on which @value{PACKAGE} operates are meant to be
contiguous arrays of @code{double} and @code{double complex} values
stored in row--major order.  Notice that the requirement of contiguous
memory is the same enforced by the libraries @cblas{} and @lapacke{}.
For a discussion of row--major versus column--major order allocation see
@ref{lapacke order, Row--major and column--major order}.

We can define matrices as follows:

@example
#include <ccdoubles.h>
#define NROWS          2
#define NCOLS          2

double          RM[NROWS * NCOLS] = @{
  1.2, 3.4,  /* this is 1st row */
  5.6, 7.8   /* this is 2nd row */
@};
double complex  CM[NROWS * NCOLS] = @{
  CCDOUBLES_CPLX(1.2, 2.3), CCDOUBLES_CPLX(3.4, 4.5),
  CCDOUBLES_CPLX(5.6, 6.7), CCDOUBLES_CPLX(7.8, 8.9)
@};
@end example

@noindent
or as follows with variable--length arrays (@acronym{VLA}, which forbid
hard--coded initialisation of slots):

@example
unsigned        nrows = 3;
unsigned        ncols = 4;
double          RM[nrows * ncols];
double complex  CM[nrows * ncols];
@end example

If we trust the compiler to allocate contiguous memory for the data area
of bidimensional arrays, we can do:

@example
#include <ccdoubles.h>
#define NROWS          2
#define NCOLS          2

double          RM[NROWS][NCOLS] = @{
  @{ 1.2, 3.4 @},  /* this is 1st row */
  @{ 5.6, 7.8 @}   /* this is 2nd row */
@};
double complex  CM[NROWS][NCOLS] = @{
  @{ CCDOUBLES_CPLX(1.2, 2.3), CCDOUBLES_CPLX(3.4, 4.5) @},
  @{ CCDOUBLES_CPLX(5.6, 6.7), CCDOUBLES_CPLX(7.8, 8.9) @}
@};
@end example

@noindent
or as follows with variable--length arrays:

@example
unsigned        nrows = 3;
unsigned        ncols = 4;
double          RM[nrows][ncols];
double complex  CM[nrows][ncols];
@end example

@c ------------------------------------------------------------

@subsubheading Memory layout of bidimensional arrays


According to a strict interpretation of the C Language Standard, the
definition of bidimensional arrays:

@example
double          RM[3][2];
complex double  CM[3][2];
@end example

@noindent
is equivalent to:

@example
double          RV0[2];
double          RV1[2];
double          RV3[2];
ccdoubles_real_result_t        RM[3];
RM[0] = &RV0[0];
RM[1] = &RV1[0];
RM[2] = &RV2[0];

double complex   CV0[2];
double complex   CV1[2];
double complex   CV3[2];
double complex * CM[3];
CM[0] = &CV0[0];
CM[1] = &CV1[0];
CM[2] = &CV2[0];
@end example

@noindent
and there is no guarantee that the data area of the arrays @code{RVx}
and @code{CVx} is contiguous; in pictures, the memory layout is:

@example
RM
-
| -------> |---|---|---| RV0
-
| -------> |---|---|---| RV1
-
| -------> |---|---|---| RV2
-
@end example

@noindent
and there is no guarantee that it is:

@example
        |    RV0    |    RV1    |    RV2    |
        |---|---|---|---|---|---|---|---|---|
RM        ^           ^           ^
-         |           |           |
| --------            |           |
-                     |           |
| --------------------            |
-                                 |
| --------------------------------
-
@end example

Nevertheless, it appears that the @gnu{} C Compiler generates code to
allocate a contiguous block of memory when a bidimensional array is
defined.

@c ------------------------------------------------------------

@subsubheading @value{PACKAGE} function implementation templates


All the matrix functions have simple implementation based on the
corresponding vector function; examples for real valued matrices:

@example
void
ccdoubles_real_matrix_add (unsigned nrows, unsigned ncols,
                           ccdoubles_real_result_t R,
                           ccdoubles_real_operand_t O1,
                           ccdoubles_real_operand_t O2)
@{
  ccdoubles_real_vector_add (nrows * ncols, R, O1, O2);
@}
void
ccdoubles_real_matrix_sin (unsigned nrows, unsigned ncols,
                           ccdoubles_real_result_t R,
                           ccdoubles_real_operand_t O)
@{
  ccdoubles_real_vector_sin (nrows * ncols, R, O);
@}
@end example

@noindent
examples for complex valued matrices:

@example
void
ccdoubles_cplx_matrix_add (unsigned nrows, unsigned ncols,
                           ccdoubles_cplx_result_t R,
                           ccdoubles_cplx_operand_t O1,
                           ccdoubles_cplx_operand_t O2)
@{
  ccdoubles_cplx_vector_add (nrows * ncols, R, O1, O2);
@}
void
ccdoubles_cplx_matrix_sin (unsigned nrows, unsigned ncols,
                           ccdoubles_cplx_result_t R,
                           ccdoubles_cplx_operand_t O)
@{
  ccdoubles_cplx_vector_sin (nrows * ncols, R, O);
@}
@end example

@c ------------------------------------------------------------

@subsubheading How to call @value{PACKAGE} functions


@value{PACKAGE} functions can be called as follows, see how the arrays
are passed as arguments:

@example
#include <ccdoubles.h>
#undef NROWS
#undef NCOLS
#define NROWS          2
#define NCOLS          2

double  O[NROWS * NCOLS] = @{
  1.2, 3.4,
  5.6, 7.8
@};
double  R[NROWS * NCOLS];

ccdoubles_real_matrix_sin(NROWS, NCOLS, R, O);
@end example

@noindent
the result is stored in the array referenced by @code{R}, overwriting
the old contents.  According to the C Language Standard, the arguments
@code{R} and @code{O} in the function call:

@example
ccdoubles_real_matrix_sin(NROWS, NCOLS, R, O);
@end example

@noindent
are implicitly converted to @code{&R[0]} and @code{&O[0]}, pointers to
the first element of the arrays.

If we trust the compiler to allocate contiguous memory for the data area
of bidimensional arrays, we can do:

@example
#include <ccdoubles.h>
#undef NROWS
#undef NCOLS
#define NROWS          2
#define NCOLS          2

double  O[NROWS][NCOLS] = @{
  @{ 1.2, 3.4 @},
  @{ 5.6, 7.8 @}
@};
double  R[NROWS][NCOLS];

ccdoubles_real_matrix_sin(NROWS, NCOLS, &R[0][0], &M[0][0]);
@end example

@noindent
and we can use the predefined macro @cfunc{MREF} as follows:

@example
#define CCDOUBLES_ENABLE_SHORT_MACROS   1
#include <ccdoubles.h>

#define NROWS          2
#define NCOLS          2

double  O[NROWS][NCOLS] = @{
  @{ 1.2, 3.4 @},
  @{ 5.6, 7.8 @}
@};
double  R[NROWS][NCOLS];

ccdoubles_real_matrix_sin(NROWS, NCOLS, MREF(R), MREF(M));
@end example

@c page
@node matrices real
@section Operations on real--valued matrices


@menu
* matrices real basic::         Basic real matrix operations.
* matrices real arithmetic::    Arithmetic real matrix operations.
* matrices real rounding::      Rounding real matrix operations.
* matrices real comparison::    Comparing real matrices.
* matrices real predicates::    Inspecting real matrices.
* matrices real special::       Special real matrix operations.
* matrices real explog::        Real matricex exponentiation and
                                logarithms.
* matrices real trigonometric:: Trigonometric real matrix operations.
* matrices real hyperbolic::    Hyperbolic real matrix operations.
* matrices real printing::      Printing real matrices.
@end menu

@c page
@node matrices real basic
@subsection Basic real matrix operations


@deftypefun void ccdoubles_real_matrix_clear (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{matrix})
Reset all the slots to @code{0.0}.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_set (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{matrix}, double @var{value})
Set all the slots to the given @var{value}.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_copy (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{dst}, ccdoubles_real_operand_t @var{src})
Copy the slots from @var{src} to @var{dst}.
@end deftypefun

@c page
@node matrices real arithmetic
@subsection Arithmetic real matrix operations


@deftypefun void ccdoubles_real_matrix_add (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
@deftypefunx void ccdoubles_real_matrix_sub (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
@deftypefunx void ccdoubles_real_matrix_mul (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
@deftypefunx void ccdoubles_real_matrix_div (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
Perform slot--by--slot addition, subtraction, multiplication and
division.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_neg (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Perform the slot--by--slot negation of the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_abs (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Compute slot--by--slot the absolute value of the operand.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void ccdoubles_real_matrix_fmod (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
Apply slot--by--slot the function @cfunc{fmod} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_drem (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
Apply slot--by--slot the function @cfunc{drem} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_remainder (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_result_t1 @varii{O})
Apply slot--by--slot the function @cfunc{remainder} to the operands.
@end deftypefun

@c page
@node matrices real rounding
@subsection Rounding real matrix operations


@deftypefun void ccdoubles_real_matrix_ceil (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{ceil}.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_floor (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{floor}.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_trunc (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{trunc}.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_round (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{round}.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_rint (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{rint}.
@end deftypefun

@c page
@node matrices real comparison
@subsection Comparing real matrices


@deftypefun void ccdoubles_real_matrix_isgreater (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_int_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
Apply slot--by--slot the function @cfunc{isgreater} to the operands.
Usage template:

@example
#include <ccdoubles.h>
#define NROWS   3
#define NCOLS   2

int     R[NROWS][NCOLS];
double  O1[NROWS][NCOLS];
double  O2[NROWS][NCOLS];

ccdoubles_real_matrix_isgreater (nrows, ncols, R, O1, O2);
@end example
@end deftypefun


@deftypefun void ccdoubles_real_matrix_isgreaterequal (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_int_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
Apply slot--by--slot the function @cfunc{isgreaterequal} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_isless (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_int_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
Apply slot--by--slot the function @cfunc{isless} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_islessequal (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_int_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
Apply slot--by--slot the function @cfunc{islessequal} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_islessgreater (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_int_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
Apply slot--by--slot the function @cfunc{islessgreater} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_isunordered (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_int_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
Apply slot--by--slot the function @cfunc{isunordered} to the operands.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void ccdoubles_real_matrix_min (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
Apply slot--by--slot the function @cfunc{fmin} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_max (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
Apply slot--by--slot the function @cfunc{fmax} to the operands.
@end deftypefun

@c page
@node matrices real predicates
@subsection Inspecting real matrices


@deftypefun void ccdoubles_real_matrix_fpclassify (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_int_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the macro @cfunc{fpclassify} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_isfinite (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_int_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the macro @cfunc{isfinite} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_isinfinite (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_int_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the macro @cfunc{isfinite} to the operand and
reverse the result.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_isnormal (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_int_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the macro @cfunc{isnormal} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_isnan (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_int_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the macro @cfunc{isnan} to the operand.
@end deftypefun

@c page
@node matrices real special
@subsection Special real matrix operations


@deftypefun void ccdoubles_real_matrix_scalar_mul (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, double @var{lambda}, const ccdoubles_real_operand_t @var{O})
Multiply the scalar @var{lambda} with all the slots in the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_linear_combination (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, double @var{alpha}, ccdoubles_real_operand_t @vari{O}, double @var{beta}, ccdoubles_real_operand_t @varii{O})
Perform the linear combination of the matrix operands and the given
scalars.  The implementation is equivalent to:

@example
for (unsigned i=0; i<nrows; ++i) @{
  for (unsigned j=0; j<ncols; ++j) @{
    R[i][j] = alpha * O1[i][j] + beta  * O2[i][j];
  @}
@}
@end example
@end deftypefun


@deftypefun void ccdoubles_real_matrix_transpose (unsigned @var{operand_nrows}, unsigned @var{operand_ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Transpose the operand.  To call this function we are meant to do:

@example
double  O[2][3];
double  R[3][2];
ccdoubles_real_matrix_transpose (2, 3, &R[0][0], &O[0][0]);
@end example

As a special case: if @var{R} and @var{O} reference the same
array @strong{and} the arguments @var{operand_nrows} and
@var{operand_ncols} are @strong{equal}: the operation is performed
faster.  If @var{R} and @var{O} reference the same array
@strong{but} the arguments @var{operand_nrows} and @var{operand_ncols}
are @strong{different}: the result is undefined.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_rowcol_mul (unsigned @var{result_nrows}, unsigned @var{operand_n}, unsigned @var{result_ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
Compute the row--column product between the operands.  To call this
function we are meant to do:

@example
double     R[result_nrows][result_ncols];
double     O1[result_nrows][operand_n];
double     O2[operand_n][result_ncols];
ccdoubles_real_matrix_rowcol_mul \
  (result_nrows, operand_n, result_ncols,
   &R[0][0], &O1[0][0], &O2[0][0]);
@end example

When possible, rather than this function, we should consider using
@acronym{CBLAS}'s @cfunc{cblas_dgemm}.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_linspace (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, double @var{start}, double @var{row_past}, double @var{col_past})
Fill the result matrix with @var{nrows} times @var{ncols} evenly--spaced
steps from @var{start} to @var{row_past} in the horizontal direction and
from @var{start} to @var{col_past} in the vertical direction.  It is
implemented as follows:

@example
double        row_step = (row_past - start) / ((double)nrows);
double        col_step = (col_past - start) / ((double)ncols);
for (unsigned i=0; i<nrows; ++i) @{
  double      row_first = ((double)i) * row_step + start;
  for (unsigned j=0; j<ncols; ++j) @{
    R[i * ncols + j] = ((double)j) * col_step + row_first;
  @}
@}
@end example

As example, the code:

@example
unsigned    nrows = 10;
unsigned    ncols = 10;
double      R[nrows][ncols];
double      start    = 0.0;
double      row_past = 10.0;
double      col_past = 10.0;
ccdoubles_real_matrix_linspace (nrows, ncols, &R[0][0],
                                start, row_past, col_past);
ccdoubles_real_matrix_print_brackets(stdout, nrows, ncols,
                                     &R[0][0]);
@end example

@noindent
prints (edited to remove trailing zeros):

@example
[[+0.0 +1.0 +2.0 +3.0 +4.0 +5.0 +6.0 +7.0 +8.0 +9.0]
 [+1.0 +2.0 +3.0 +4.0 +5.0 +6.0 +7.0 +8.0 +9.0 +10.0]
 [+2.0 +3.0 +4.0 +5.0 +6.0 +7.0 +8.0 +9.0 +10.0 +11.0]
 [+3.0 +4.0 +5.0 +6.0 +7.0 +8.0 +9.0 +10.0 +11.0 +12.0]
 [+4.0 +5.0 +6.0 +7.0 +8.0 +9.0 +10.0 +11.0 +12.0 +13.0]
 [+5.0 +6.0 +7.0 +8.0 +9.0 +10.0 +11.0 +12.0 +13.0 +14.0]
 [+6.0 +7.0 +8.0 +9.0 +10.0 +11.0 +12.0 +13.0 +14.0 +15.0]
 [+7.0 +8.0 +9.0 +10.0 +11.0 +12.0 +13.0 +14.0 +15.0 +16.0]
 [+8.0 +9.0 +10.0 +11.0 +12.0 +13.0 +14.0 +15.0 +16.0 +17.0]
 [+9.0 +10.0 +11.0 +12.0 +13.0 +14.0 +15.0 +16.0 +17.0 +18.0]]
@end example
@end deftypefun

@c page
@node matrices real explog
@subsection Real matrices exponentiation and logarithms


@deftypefun void ccdoubles_real_matrix_exp (unsigned @var{ncols}, unsigned @var{nrows}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{exp} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_exp10 (unsigned @var{ncols}, unsigned @var{nrows}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @code{exp(X * log(10))} to the
operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_exp2 (unsigned @var{ncols}, unsigned @var{nrows}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{exp2} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_log (unsigned @var{ncols}, unsigned @var{nrows}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{log} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_log10 (unsigned @var{ncols}, unsigned @var{nrows}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{log10} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_log2 (unsigned @var{ncols}, unsigned @var{nrows}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{log2} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_logb (unsigned @var{ncols}, unsigned @var{nrows}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{logb} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_pow (unsigned @var{ncols}, unsigned @var{nrows}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
Apply slot--by--slot the function @cfunc{pow} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_sqrt (unsigned @var{ncols}, unsigned @var{nrows}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{sqrt} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_cbrt (unsigned @var{ncols}, unsigned @var{nrows}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{cbrt} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_hypot (unsigned @var{ncols}, unsigned @var{nrows}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
Apply slot--by--slot the function @cfunc{hypot} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_expm1 (unsigned @var{ncols}, unsigned @var{nrows}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{expm1} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_log1p (unsigned @var{ncols}, unsigned @var{nrows}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Apply slot--by--slot the function @cfunc{log1p} to the operand.
@end deftypefun

@c page
@node matrices real trigonometric
@subsection Trigonometric real matrix operations


@deftypefun void ccdoubles_real_matrix_sin (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
@deftypefunx void ccdoubles_real_matrix_cos (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
@deftypefunx void ccdoubles_real_matrix_tan (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Compute slot--by--slot the trigonometric sine, cosine, tangent of the
operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_asin (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
@deftypefunx void ccdoubles_real_matrix_acos (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
@deftypefunx void ccdoubles_real_matrix_atan (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Compute slot--by--slot the trigonometric arc sine, arc cosine, arc
tangent of the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_atan2 (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @vari{O}, ccdoubles_real_operand_t @varii{O})
Compute slot--by--slot the trigonometric arc tangent of the operands.
The implementation is equivalent to:

@example
for (unsigned i=0; i<nrows; ++i) @{
  for (unsigned j=0; i<ncols; ++j) @{
    O[i][j] = atan2(O1[i][j], O2[i][j]);
  @}
@}
@end example

@glibcref{Inverse Trig Functions, atan2} for details on @cfunc{atan2}.
@end deftypefun

@c page
@node matrices real hyperbolic
@subsection Hyperbolic real matrix operations


@deftypefun void ccdoubles_real_matrix_sinh (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
@deftypefunx void ccdoubles_real_matrix_cosh (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
@deftypefunx void ccdoubles_real_matrix_tanh (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Compute slot--by--slot the hyperbolic sine, cosine, tangent of the
operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_asinh (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
@deftypefunx void ccdoubles_real_matrix_acosh (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
@deftypefunx void ccdoubles_real_matrix_atanh (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Compute slot--by--slot the hyperbolic arc sine, arc cosine, arc tangent
of the operand.
@end deftypefun

@c page
@node matrices real printing
@subsection Printing real matrices


@deftypefun void ccdoubles_real_matrix_print_display (FILE * @var{f}, const char * @var{name}, unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_operand_t @var{O})
Print on @var{f} a layout of the operand.  @var{name} must be a pointer
to an @asciiz{} string representing the operand name.  Example:

@example
#undef NROWS
#undef NCOLS
#define NROWS           2
#define NCOLS           3
double      O[NROWS][NCOLS] = @{
  @{ 1.1, 1.2, 1.3 @},
  @{ 2.1, 2.2, 2.3 @}
@};
ccdoubles_real_matrix_print_display \
  (stdout, "O", NROWS, NCOLS, &O[0][0]);
@end example

@noindent
will print:

@smallexample
Row-major matrix O (dimension 2 x 3) (displayed in row-major order):
| (1,1) +1.100000 ; (1,2) +1.200000 ; (1,3) +1.300000  |
| (2,1) +2.100000 ; (2,2) +2.200000 ; (2,3) +2.300000  |
@end smallexample
@end deftypefun


@deftypefun void ccdoubles_real_matrix_print_brackets (FILE * @var{f}, unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_operand_t @var{O})
Print on @var{f} a layout of the operand.  Example:

@example
#undef NROWS
#undef NCOLS
#define NROWS           2
#define NCOLS           3
double      O[NROWS][NCOLS] = @{
  @{ 1.1, 1.2, 1.3 @},
  @{ 2.1, 2.2, 2.3 @}
@};
ccdoubles_real_matrix_print_brackets \
  (stdout, NROWS, NCOLS, &O[0][0]);
@end example

@noindent
will print:

@smallexample
[[+1.100000 +1.200000 +1.300000]
 [+2.100000 +2.200000 +2.300000]]
@end smallexample
@end deftypefun


@deftypefun void ccdoubles_real_matrix_print_braces (FILE * @var{f}, unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_operand_t @var{O})
Print on @var{f} a layout of the operand.  Example:

@example
#undef NROWS
#undef NCOLS
#define NROWS           2
#define NCOLS           3
double      O[NROWS][NCOLS] = @{
  @{ 1.1, 1.2, 1.3 @},
  @{ 2.1, 2.2, 2.3 @}
@};
ccdoubles_real_matrix_print_braces \
  (stdout, NROWS, NCOLS, &O[0][0]);
@end example

@noindent
will print:

@smallexample
@{@{+1.100000, +1.200000, +1.300000@},
 @{+2.100000, +2.200000, +2.300000@}@}
@end smallexample
@end deftypefun

@c page
@node matrices cplx
@section Operations on complex--valued matrices


@menu
* matrices cplx basic::         Basic complex matrix operations.
* matrices cplx arithmetic::    Arithmetic complex matrix operations.
* matrices cplx special::       Special complex matrix operations.
* matrices cplx explog::        Complex matrices exponentiation and
                                logarithms.
* matrices cplx trigonometric:: Trigonometric complex matrix operations.
* matrices cplx hyperbolic::    Hyperbolic complex matrix operations.
* matrices cplx printing::      Printing complex matrices.
@end menu

@c page
@node matrices cplx basic
@subsection Basic complex matrix operations


@deftypefun void ccdoubles_cplx_matrix_clear (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{matrix})
Reset all the slots to complex numbers with real part @code{0.0} and
complex part @code{0.0}.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_set (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{matrix}, double complex @var{value})
Set all the slots to the given @var{value}.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_set_split (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{vector}, double @var{value_re}, double @var{value_im})
Set all the slots to a complex number having @var{value_re} as real part
and @var{value_im} as imaginary part.  This function is like
@cfunc{ccdoubles_cplx_matrix_set}, but splitting the real and imaginary
parts makes it easier to interface it with foreign languages.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_copy (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{dst}, ccdoubles_cplx_operand_t @var{src})
Copy the slots from @var{src} to @var{dst}.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void ccdoubles_cplx_matrix_real (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
Extract slot--by--slot the real part of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_imag (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
Extract slot--by--slot the imaginary part of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_magnitude (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
Extract slot--by--slot the magnitude of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_angle (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
Extract slot--by--slot the angle of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_conj (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
Compute slot--by--slot the conjugate of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_from_rect (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{R}, ccdoubles_real_result_t @var{real}, ccdoubles_real_result_t imag)
Build slot--by--slot a complex valued matrix from the real and imaginary
parts.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_from_polar (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{R}, ccdoubles_real_operand_t @var{magnitude}, ccdoubles_real_operand_t @var{angle})
Build slot--by--slot a complex valued matrix from the magnitude and
angle.
@end deftypefun

@c page
@node matrices cplx arithmetic
@subsection Arithmetic complex matrix operations


@deftypefun void ccdoubles_cplx_matrix_add (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @vari{O}, ccdoubles_cplx_operand_t @varii{O})
@deftypefunx void ccdoubles_cplx_matrix_sub (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @vari{O}, ccdoubles_cplx_operand_t @varii{O})
@deftypefunx void ccdoubles_cplx_matrix_mul (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @vari{O}, ccdoubles_cplx_operand_t @varii{O})
@deftypefunx void ccdoubles_cplx_matrix_div (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @vari{O}, ccdoubles_cplx_operand_t @varii{O})
Perform slot--by--slot addition, subtraction, multiplication and
division.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_neg (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
Perform the slot--by--slot negation of the operand.
@end deftypefun

@c page
@node matrices cplx special
@subsection Special complex matrix operations


@deftypefun void ccdoubles_cplx_matrix_scalar_mul (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{R}, double complex  @var{lambda}, const ccdoubles_cplx_operand_t @var{O})
Multiply the scalar @var{lambda} with all the slots in the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_scalar_mul_split (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{R}, double @var{lambda_re}, double @var{lambda_im}, const ccdoubles_cplx_operand_t @var{O})
Multiply the scalar having real part @var{lambda_re} and imaginary part
@var{lambda_im} with all the slots in the operand.  This function is
like @cfunc{ccdoubles_cplx_matrix_scalar_mul}, but splitting the real
and imaginary parts of the coefficient makes it easier to interface it
with foreign languages.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_linear_combination (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{R}, double complex @var{alpha}, ccdoubles_cplx_operand_t @vari{O}, double complex @var{beta}, ccdoubles_cplx_operand_t @varii{O})
Perform the linear combination of the matrix operands and the given
scalars.  The implementation is equivalent to:

@example
for (unsigned i=0; i<nrows; ++i) @{
  for (unsigned j=0; j<ncols; ++j) @{
    R[i][j] = alpha * O1[i][j] + beta  * O2[i][j];
  @}
@}
@end example
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_linear_combination_split (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{R}, double @var{alpha_re}, double @var{alpha_im}, ccdoubles_cplx_operand_t @vari{O}, double @var{beta_re}, double @var{beta_im}, ccdoubles_cplx_operand_t @varii{O})
Perform the linear combination of the matrix operands and the given
scalars.  This function is like
@cfunc{ccdoubles_cplx_matrix_linear_combination}, but splitting the real
and imaginary parts of the coefficient makes it easier to interface it
with foreign languages.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_transpose (unsigned @var{operand_nrows}, unsigned @var{operand_ncols}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
Transpose the operand.  To call this function we are meant to do:

@example
double complex  O[2][3];
double complex  R[3][2];
ccdoubles_cplx_matrix_transpose (2, 3, &R[0][0], &O[0][0]);
@end example

As a special case: if @var{R} and @var{O} reference the same
array @strong{and} the arguments @var{operand_nrows} and
@var{operand_ncols} are @strong{equal}: the operation is performed
faster.  If @var{R} and @var{O} reference the same array
@strong{but} the arguments @var{operand_nrows} and @var{operand_ncols}
are @strong{different}: the result is undefined.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_conjugate_transpose (unsigned @var{operand_nrows}, unsigned @var{operand_ncols}, ccdoubles_real_result_t @var{R}, ccdoubles_real_operand_t @var{O})
Transpose the operand and conjugate its elements; notice that the
elements on the main diagonal are conjugate, too.  To call this function
we are meant to do:

@example
double  O[2][3];
double  R[3][2];
ccdoubles_cplx_matrix_conjugate_transpose \
  (2, 3, &R[0][0], &O[0][0]);
@end example

As a special case: if @var{R} and @var{O} reference the same
array @strong{and} the arguments @var{operand_nrows} and
@var{operand_ncols} are @strong{equal}: the operation is performed
faster.  If @var{R} and @var{O} reference the same array
@strong{but} the arguments @var{operand_nrows} and @var{operand_ncols}
are @strong{different}: the result is undefined.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_rowcol_mul (unsigned @var{result_nrows}, unsigned @var{operand_n}, unsigned @var{result_ncols}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @vari{O}, ccdoubles_cplx_operand_t @varii{O})
Compute the row--column product between the operands.  To call this
function we are meant to do:

@example
double     R[result_nrows][result_ncols];
double     O1[result_nrows][operand_n];
double     O2[operand_n][result_ncols];
ccdoubles_cplx_matrix_rowcol_mul \
  (result_nrows, operand_n, result_ncols,
   &R[0][0], &O1[0][0], &O2[0][0]);
@end example

When possible, rather than this function, we should consider using
@acronym{CBLAS}'s @cfunc{cblas_zgemm}.
@end deftypefun

@c page
@node matrices cplx explog
@subsection Complex matrices exponentiation and logarithms


@deftypefun void ccdoubles_cplx_matrix_exp (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
Apply slot--by--slot the function @cfunc{cexp} to the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_log (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
Apply slot--by--slot the function @cfunc{clog} to the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_log10 (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
Apply slot--by--slot the function @cfunc{log10(cabs(Z)) + I * carg(Z)}
to the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_sqrt (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
Apply slot--by--slot the function @cfunc{csqrt} to the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_pow (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @vari{O}, ccdoubles_cplx_operand_t @varii{O})
Apply slot--by--slot the function @cfunc{cpow} to the operands.
@end deftypefun

@c page
@node matrices cplx trigonometric
@subsection Trigonometric complex matrix operations


@deftypefun void ccdoubles_cplx_matrix_sin (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
@deftypefunx void ccdoubles_cplx_matrix_cos (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
@deftypefunx void ccdoubles_cplx_matrix_tan (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
Compute slot--by--slot the trigonometric sine, cosine, tangent of the
operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_asin (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
@deftypefunx void ccdoubles_cplx_matrix_acos (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
@deftypefunx void ccdoubles_cplx_matrix_atan (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
Compute slot--by--slot the trigonometric arc sine, arc cosine, arc
tangent of the operand.
@end deftypefun

@c page
@node matrices cplx hyperbolic
@subsection Hyperbolic complex matrix operations


@deftypefun void ccdoubles_cplx_matrix_sinh (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
@deftypefunx void ccdoubles_cplx_matrix_cosh (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
@deftypefunx void ccdoubles_cplx_matrix_tanh (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
Compute slot--by--slot the hyperbolic sine, cosine, tangent of the
operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_asinh (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
@deftypefunx void ccdoubles_cplx_matrix_acosh (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
@deftypefunx void ccdoubles_cplx_matrix_atanh (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_result_t @var{R}, ccdoubles_cplx_operand_t @var{O})
Compute slot--by--slot the hyperbolic arc sine, arc cosine, arc tangent
of the operand.
@end deftypefun

@c page
@node matrices cplx printing
@subsection Printing complex matrices


@deftypefun void ccdoubles_cplx_matrix_print_display (FILE * @var{f}, const char * @var{name}, unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_operand_t @var{O})
Print on @var{f} a layout of the operand.  @var{name} must be a pointer
to an @asciiz{} string representing the operand name.  Example:

@example
#define CPLX(REAL,IMAG)  CCDOUBLES_CPLX((REAL),(IMAG))
#undef NROWS
#undef NCOLS
#define NROWS           2
#define NCOLS           3
double complex  O[NROWS][NCOLS] = @{
  @{ CPLX(1.1,-1.1), CPLX(1.2,-1.2), CPLX(1.3,-1.3) @},
  @{ CPLX(2.1,-2.1), CPLX(2.2,-2.2), CPLX(2.3,-2.3) @}
@};
ccdoubles_cplx_matrix_print_display \
  (stdout, "O", NROWS, NCOLS, &O[0][0]);
@end example

@noindent
will print:

@smallexample
Row-major matrix O (dimension 2 x 3) (displayed in row-major order):
| (1,1) +1.100000-1.100000i ; (1,2) +1.200000-1.200000i ; (1,3) +1.300000-1.300000i  |
| (2,1) +2.100000-2.100000i ; (2,2) +2.200000-2.200000i ; (2,3) +2.300000-2.300000i  |
@end smallexample
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_print_brackets (FILE * @var{f}, unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_operand_t @var{O})
Print on @var{f} a layout of the operand.  Example:

@example
#define CPLX(REAL,IMAG)  CCDOUBLES_CPLX((REAL),(IMAG))
#undef NROWS
#undef NCOLS
#define NROWS           2
#define NCOLS           3
double complex  O[NROWS][NCOLS] = @{
  @{ CPLX(1.1,-1.1), CPLX(1.2,-1.2), CPLX(1.3,-1.3) @},
  @{ CPLX(2.1,-2.1), CPLX(2.2,-2.2), CPLX(2.3,-2.3) @}
@};
ccdoubles_cplx_matrix_print_brackets \
  (stdout, NROWS, NCOLS, &O[0][0]);
@end example

@noindent
will print:

@smallexample
[[+1.100000-1.100000i +1.200000-1.200000i +1.300000-1.300000i]
 [+2.100000-2.100000i +2.200000-2.200000i +2.300000-2.300000i]]
@end smallexample
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_print_braces (FILE * @var{f}, unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_cplx_operand_t @var{O})
Print on @var{f} a layout of the operand.  Example:

@example
#define CPLX(REAL,IMAG)  CCDOUBLES_CPLX((REAL),(IMAG))
#undef NROWS
#undef NCOLS
#define NROWS           2
#define NCOLS           3
double complex  O[NROWS][NCOLS] = @{
  @{ CPLX(1.1,-1.1), CPLX(1.2,-1.2), CPLX(1.3,-1.3) @},
  @{ CPLX(2.1,-2.1), CPLX(2.2,-2.2), CPLX(2.3,-2.3) @}
@};
ccdoubles_cplx_matrix_print_braces \
  (stdout, NROWS, NCOLS, &O[0][0]);
@end example

@noindent
will print:

@smallexample
@{@{+1.100000-1.100000i, +1.200000-1.200000i, +1.300000-1.300000i@},
 @{+2.100000-2.100000i, +2.200000-2.200000i, +2.300000-2.300000i@}@}
@end smallexample
@end deftypefun

@c page
@node matrices int
@section Operations on @code{int}--valued matrices


Matrices of integer numbers are useful because some predicate functions
acting on matrices of @code{double} store the result in an array
integers.

@menu
* matrices int basic::          Basic @code{int} vector operations.
* matrices int printing::       Printing @code{int} vectors.
@end menu

@c page
@node matrices int basic
@subsection Basic @code{int} vector operations


@deftypefun void ccdoubles_int_matrix_clear (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_int_result_t @var{matrix})
Reset all the slots to @code{0}.
@end deftypefun


@deftypefun void ccdoubles_int_matrix_set (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_int_result_t @var{matrix}, double @var{value})
Set all the slots to the given @var{value}.
@end deftypefun


@deftypefun void ccdoubles_int_matrix_copy (unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_int_result_t @var{dst}, ccdoubles_int_operand_t @var{src})
Copy the slots from @var{src} to @var{dst}.
@end deftypefun

@c page
@node matrices int printing
@subsection Printing @code{int} vectors


@deftypefun void ccdoubles_int_matrix_print_display (FILE * @var{f}, const char * @var{name}, unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_int_operand_t @var{O})
Print on @var{f} a layout of the operand.  @var{name} must be a pointer
to an @asciiz{} string representing the operand name.  Example:

@example
#undef NROWS
#undef NCOLS
#define NROWS           2
#define NCOLS           3
int     O[NROWS][NCOLS] = @{
  @{ 11, 22, 33 @},
  @{ 44, 55, 66 @}
@};
ccdoubles_int_matrix_print_display \
  (stdout, "O", NROWS, NCOLS, &O[0][0]);
@end example

@noindent
will print:

@smallexample
Row-major matrix O (dimension 2 x 3) (displayed in row-major order):
| (1,1) +11 ; (1,2) +22 ; (1,3) +33 |
| (2,1) +44 ; (2,2) +55 ; (2,3) +66 |
@end smallexample
@end deftypefun


@deftypefun void ccdoubles_int_matrix_print_brackets (FILE * @var{f}, unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_int_operand_t @var{O})
Print on @var{f} a layout of the operand.  Example:

@example
#undef NROWS
#undef NCOLS
#define NROWS           2
#define NCOLS           3
int     O[NROWS][NCOLS] = @{
  @{ 11, 22, 33 @},
  @{ 44, 55, 66 @}
@};
ccdoubles_int_matrix_print_brackets \
  (stdout, NROWS, NCOLS, &O[0][0]);
@end example

@noindent
will print:

@smallexample
[[+11 +22 +33]
 [+44 +55 +66]]
@end smallexample
@end deftypefun


@deftypefun void ccdoubles_int_matrix_print_braces (FILE * @var{f}, unsigned @var{nrows}, unsigned @var{ncols}, ccdoubles_int_operand_t @var{O})
Print on @var{f} a layout of the operand.  Example:

@example
#undef NROWS
#undef NCOLS
#define NROWS           2
#define NCOLS           3
int     O[NROWS][NCOLS] = @{
  @{ 11, 22, 33 @},
  @{ 44, 55, 66 @}
@};
ccdoubles_int_matrix_print_braces \
  (stdout, NROWS, NCOLS, &O[0][0]);
@end example

@noindent
will print:

@smallexample
@{@{+11, +22, +33@},
 @{+44, +55, +66@}@}
@end smallexample
@end deftypefun

@c page
@node lapacke
@chapter Utilities to operate with @cblas{} and @lapacke{}


@menu
* lapacke order::               Row--major and column--major order.
@end menu

@c page
@node lapacke order
@section Row--major and column--major order


In this section we will assume the use of a C language compiler that:
when allocating bidimensional arrays on the stack, generates code to
allocate a contiguous memory region for the data area; this is
@strong{not} guaranteed by the C Language Standard; @ref{matrices intro,
Introduction to matrix operations}.

Row--major and column--major are ways to serialise the contents of a
bidimensional array.  The mathematical entity matrix:

@example
 -           -
| a11 a12 a13 |
| a21 a22 a23 |
 -           -
@end example

@noindent
has no ordering by itself; but, by mathematical convention, we indicate
its elements as @math{a_@{ij@}}, where @math{i} is the row index and
@math{j} is the column index; the row index first and the column index
second.

When we represent such matrix as a bidimensional C language array: the
elements are stored in memory in row--major order or in column--major
order.  As defined by the C Language Standard, the bidimensional array:

@example
#define M       2
#define N       3
double  A[M][N] = @{
  @{ 1.1, 1.2, 1.3 @},
  @{ 2.1, 2.2, 2.3 @}
@};
@end example

@noindent
is stored in memory in ``first dimension major'' order, that is:

@example
low memory addresses ---> high memory addresses

   1.1     1.2     1.3     2.1     2.2     2.3
|-------|-------|-------|-------|-------|-------|
 A[0][0] A[0][1] A[0][2] A[1][0] A[1][1] A[1][2]
@end example

When referencing the elements we write @code{A[i][j]}, where @code{i} is
the index of the first dimension and @code{j} is the index of the second
dimension.

@itemize
@item
If we interpret @code{i} as row index and @code{j} as column index: the
matrix is stored in row--major order.

@item
If we interpret @code{i} as column index and @code{j} as row index: the
matrix is stored in column--major order.
@end itemize

In other words, given the mathematical matrix:

@example
 -           -     -           -
| a11 a12 a13 | = | 1.1 1.2 1.3 |
| a21 a22 a23 |   | 2.1 2.2 2.3 |
 -           -     -           -
@end example

@noindent
we can represent it in row--major order as:

@example
#define NROWS   2
#define NCOLS   3
double  A[NROWS][NCOLS] = @{
  @{ 1.1, 1.2, 1.3 @},
  @{ 2.1, 2.2, 2.3 @}
@};

 low memory addresses ---> high memory addresses

   1.1     1.2     1.3     2.1     2.2     2.3
|-------|-------|-------|-------|-------|-------|
 A[0][0] A[0][1] A[0][2] A[1][0] A[1][1] A[1][2]
@end example

@noindent
and in column--major order as:

@example
#define NROWS   2
#define NCOLS   3
double  A[NCOLS][NROWS] = @{
  @{ 1.1, 2.1 @},
  @{ 1.2, 2.2 @},
  @{ 1.3, 2.3 @}
@};

 low memory addresses ---> high memory addresses

   1.1     2.1     1.2     2.2     1.3     2.3
|-------|-------|-------|-------|-------|-------|
 A[0][0] A[0][1] A[1][0] A[1][1] A[2][1] A[2][2]
@end example

Given a mathematical matrix represented as C language bidimensional
array in row--major order: the mathematical operation ``matrix
transposition'' applied to the array transforms the row--major
representation into the column--major representation, and vice versa.
Beware that, when using complex valued matrices: the usual operation is
``matrix transposition and conjugation'', which, obviously, does not
have this property.

@c ------------------------------------------------------------

@subsubheading Ordering under @cblas{} and @lapacke{}

The libraries @blas{} and @lapack{} are written in the Fortran language;
by language definition: bidimensional arrays in Fortran are represented
in column--major order.

The libraries @cblas{} and @lapacke{} are C language interfaces to
@blas{} and @lapack{}; one of the features of these libraries is to
allow the selection of ordering representation by the function
parameters:

@table @code
@item const enum CBLAS_ORDER @var{Order}
For @cblas{}.  Its values can be @code{CblasRowMajor} and
@code{CblasColMajor}.

@item int @var{matrix_order}
For @lapacke{}.  Its values can be @code{LAPACK_ROW_MAJOR} and
@code{LAPACK_COL_MAJOR}.
@end table

We have seen that, in the C language, we are free to select row--major
or column--major representations by simply assigning meaning to the
first and second dimensions of a bidimensional array.  So we can simply
adopt the mathematical convention for the C language representation,
define all the matrices as:

@example
#define NROWS   2
#define NCOLS   3
double  A[NROWS][NCOLS] = @{
  @{ 1.1, 1.2, 1.3 @},
  @{ 2.1, 2.2, 2.3 @}
@};
@end example

@noindent
and interpret the first dimension as rows and the second dimension as
columns.  When using @cblas{} we will use the argument
@code{CblasRowMajor}, when using @lapacke{} we will use the argument
@code{LAPACK_ROW_MAJOR}.

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include gpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DOCUMENTATION_URL}

@noindent
the latest release of this package can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

