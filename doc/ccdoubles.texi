\input texinfo.tex
@c %**start of header
@setfilename ccdoubles.info
@settitle CCDoubles
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCDoubles

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCDoubles

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ccdoubles

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2014

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a
C99 language library implementing simple routines for vectors and
matrices of @code{double} and @code{double complex} values.  The package
is distributed under the terms of the @gnu{} General Public License
(@gpl{}).

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with
Invariant Sections being ``@gnu{} Free Documentation License'' and
``@gnu{} General Public License'', no Front--Cover Texts, and no
Back--Cover Texts.  A copy of the license is included in the section
entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ccdoubles: (ccdoubles).       CCDoubles.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* scalars::                     Operations on scalar numbers.
* vectors::                     Operations on vectors.
* matrices::                    Operations on matrices.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* resources::                   On--line resources.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a
C99 language library implementing simple routines for vectors and
matrices of @code{double} and @code{double complex} values.  This
library is meant to be used as companion for more sophisticated
libraries such as @acronym{CBLAS} and @acronym{LAPACKE}.

@value{PACKAGE} installs the single header file @file{ccdoubles.h}.  All
the function names in the @api{} are prefixed with @code{ccd_}; all the
constant names are prefixed with @code{CCD_}; all the type names are
prefixed with @code{ccd_} and suffixed with @code{_t}.

@menu
* overview linking::            Linking code with the library.
@end menu

@c page
@node overview linking
@section Linking code with the library


This package installs a data file for @command{pkg-config}, so when
searching for the installed library with the @gnu{} Autotools, we can:

@itemize
@item
Install the file @file{pkg.m4} from @file{/usr/share/aclocal} into the
source tree of the package, for example under @file{meta/autoconf/}.

@item
Include @file{pkg.m4} in the template by adding the following line to
@file{acinclude.m4}:

@example
m4_include(meta/autoconf/pkg.m4)
@end example

@item
Just add the following macro use to @file{configure.ac}:

@example
PKG_CHECK_MODULES([CCDOUBLES],[ccdoubles >= 0.1])
@end example

@noindent
which will set the variables @code{CCDOUBLES_LIBS} and
@code{CCDOUBLES_CFLAGS}.
@end itemize

Alternatively we can use the raw @gnu{} Autoconf macros:

@example
AC_CHECK_LIB([ccdoubles],[ccd_version_string],,
  [AC_MSG_FAILURE([test for CCDoubles library failed])])
AC_CHECK_HEADERS([ccdoubles.h],,
  [AC_MSG_FAILURE([test for CCDoubles header failed])])
@end example

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the
@gnu{} Autotools.  For an explanation of interface numbers as managed by
@gnu{} Libtool @xref{Libtool versioning, interface, Libtool's versioning
system, libtool, Shared library support for @gnu{}}.


@deftypefun {const char *} ccd_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing
the interface version number.
@end deftypefun


@deftypefun int ccd_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int ccd_version_interface_revision (void)
Return an integer representing the library interface current revision
number.
@end deftypefun


@deftypefun int ccd_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node scalars
@chapter Operations on scalar numbers


@menu
* scalars complex::             Operations on scalar complex numbers.
@end menu

@c page
@node scalars complex
@section Operations on scalar complex numbers


The C99 language standard library defines common operations on scalar
@code{double complex} numbers; in addition @value{PACKAGE} defines
convenience functions to perform the same.


@deftypefn {Preprocessor Macro} {double complex} CCDOUBLES_CPLX (double @var{REAL}, double @var{IMAG})
Build and return a new @code{double complex} value.  Expands into:

@example
(((double)(@var{REAL})) + ((double)(@var{IMAG})) * _Complex_I)
@end example

@quotation
@strong{NOTE} The latest C Language Standard defines the same operation
with the preprocessor macro @code{CMPLX(@var{REAL}, @var{IMAG})}.
@end quotation
@end deftypefn


@deftypefun {double complex} ccdoubles_cplx_mul (double complex @vari{O}, double complex @varii{O})
Even though C99 supports the multiplication operation as:

@example
#include <ccdoubles.h>

double complex  O1 = CCDOUBLES_CPLX(1.2, 3.4);
double complex  O2 = CCDOUBLES_CPLX(5.6, 7.8);
double complex  R  = O1 * O2;

printf("R = %lf%+lfi\n", creal(R), cimag(R));
@print{} R = -19.800000+28.400000i
@end example

@noindent
this function computes and returns the product between the operands.
Example:

@example
#include <ccdoubles.h>

double complex  O1 = CCDOUBLES_CPLX(1.2, 3.4);
double complex  O2 = CCDOUBLES_CPLX(5.6, 7.8);
double complex  R;

R = ccdoubles_cplx_mul(O1, O2);

printf("R = %lf%+lfi\n", creal(R), cimag(R));
@print{} R = -19.800000+28.400000i
@end example
@end deftypefun


@deftypefun {double complex} ccdoubles_cplx_div (double complex @vari{O}, double complex @varii{O})
Even though C99 supports the division operation as:

@example
#include <ccdoubles.h>

double complex  O1 = CCDOUBLES_CPLX(1.2, 3.4);
double complex  O2 = CCDOUBLES_CPLX(5.6, 7.8);
double complex  R  = O1 / O2;

printf("R = %lf%+lfi\n", creal(R), cimag(R));
@print{} R = 0.360521+0.104989i
@end example

@noindent
this function computes and returns the division between the operands.
Example:

@example
#include <ccdoubles.h>

double complex  O1 = CCDOUBLES_CPLX(1.2, 3.4);
double complex  O2 = CCDOUBLES_CPLX(5.6, 7.8);
double complex  R;

R = ccdoubles_cplx_div(O1, O2);

printf("R = %lf%+lfi\n", creal(R), cimag(R));
@print{} R = 0.360521+0.104989i
@end example
@end deftypefun


@deftypefun {double complex} ccdoubles_cplx_neg (double complex @var{O})
Even though C99 supports the negation operation as:

@example
#include <ccdoubles.h>

double complex  O = CCDOUBLES_CPLX(1.2, 3.4);
double complex  R = - O;

printf("R = %lf%+lfi\n", creal(R), cimag(R));
@print{} R = -1.200000-3.400000i
@end example

@noindent
this function computes and returns the negation of the operand.
Example:

@example
#include <ccdoubles.h>

double complex  O = CCDOUBLES_CPLX(1.2, 3.4);
double complex  R;

R = ccdoubles_cplx_neg(O);

printf("R = %lf%+lfi\n", creal(R), cimag(R));
@print{} R = -1.200000-3.400000i
@end example
@end deftypefun

@c page
@node vectors
@chapter Operations on vectors


@menu
* vectors intro::               Introduction to vector operations.
* vectors real::                Operations on real--valued vectors.
* vectors cplx::                Operations on complex--valued vectors.
@end menu

@c page
@node vectors intro
@section Introduction to vector operations


The vectors on which @value{PACKAGE} operates are meant to be contiguous
arrays of @code{double} and @code{double complex} values, defined as
follows:

@example
#include <ccdoubles.h>
#undef NSLOTS
#define NSLOTS          2

double          RV[NSLOTS] = @{ 1.2, 3.4 @};
double complex  CV[NSLOTS] = @{
  CCDOUBLES_CPLX(1.2, 3.4),
  CCDOUBLES_CPLX(5.6, 7.8)
@};
@end example

@noindent
or as follows with dynamic size (which forbids hard--coded
initialisation of slots):

@example
size_t          nslots = 1;
double          RV[nslots];
double complex  CV[nslots];
@end example

All the functions have simple implementation involving an iteration over
the vector's slots using @code{restrict} pointers; examples for real
valued vectors:

@example
void
ccdoubles_real_vector_add (size_t nslots,
                           double * restrict result,
                           double * restrict operand1,
                           double * restrict operand2)
@{
  for (size_t i=0; i<nslots; ++i) @{
    result[i] = operand1[i] + operand2[i];
  @}
@}
void
ccdoubles_real_vector_sin (size_t nslots,
                           double * restrict result,
                           double * restrict operand)
@{
  for (size_t i=0; i<nslots; ++i) @{
    result[i] = sin(operand[i]);
  @}
@}
@end example

@noindent
examples for complex valued vectors:

@example
void
ccdoubles_cplx_vector_add (size_t nslots,
			   double complex * restrict result,
			   double complex * restrict operand1,
			   double complex * restrict operand2)
@{
  for (size_t i=0; i<nslots; ++i) @{
    result[i] = operand1[i] + operand2[i];
  @}
@}
void
ccdoubles_cplx_vector_sin (size_t nslots,
			   double complex * restrict result,
			   double complex * restrict operand)
@{
  for (size_t i=0; i<nslots; ++i) @{
    result[i] = csin(operand[i]);
  @}
@}
@end example

@value{PACKAGE} functions can be called as follows, see how the arrays
are passed as arguments:

@example
#include <ccdoubles.h>
#undef NSLOTS
#define NSLOTS         2

double  V[NSLOTS] = @{ 1.2, 3.4 @};
double  R[NSLOTS];

ccdoubles_real_vector_sin(NROWS, NCOLS, R, V);
@end example

@noindent
the result is stored the array referenced by @code{R}, overwriting the
old contents.

@c page
@node vectors real
@section Operations on real--valued vectors


@menu
* vectors real basic::          Basic real vector operations.
* vectors real arithmetic::     Arithmetic real vector operations.
* vectors real rounding::       Rounding real vector operations.
* vectors real special::        Special real vector operations.
* vectors real trigonometric::  Trigonometric real vector operations.
* vectors real hyperbolic::     Hyperbolic real vector operations.
@end menu

@c page
@node vectors real basic
@subsection Basic real vector operations


@deftypefun void ccdoubles_real_vector_clear (size_t @var{nslots}, double * @var{vector})
Reset all the slots to @code{0.0}.
@end deftypefun


@deftypefun void ccdoubles_real_vector_set (size_t @var{nslots}, double * @var{vector}, double @var{value})
Set all the slots to the given @var{value}.
@end deftypefun


@deftypefun void ccdoubles_real_vector_copy (size_t @var{nslots}, double * @var{dst}, double * @var{src})
Copy the slots from @var{src} to @var{dst}.
@end deftypefun

@c page
@node vectors real arithmetic
@subsection Arithmetic real vector operations


@deftypefun void ccdoubles_real_vector_add (size_t @var{nslots}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
@deftypefunx void ccdoubles_real_vector_sub (size_t @var{nslots}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
@deftypefunx void ccdoubles_real_vector_mul (size_t @var{nslots}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
@deftypefunx void ccdoubles_real_vector_div (size_t @var{nslots}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
Perform slot--by--slot addition, subtraction, multiplication and
division.
@end deftypefun


@deftypefun void ccdoubles_real_vector_neg (size_t @var{nslots}, double * @var{result}, double * @var{operand})
Perform the slot--by--slot negation of the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_abs (size_t @var{nslots}, double * @var{result}, double * @var{operand})
Compute slot--by--slot the absolute value of the operand.
@end deftypefun

@c page
@node vectors real rounding
@subsection Rounding real vector operations


@deftypefun void ccdoubles_real_vector_ceil (size_t @var{nslots}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{ceil}.
@end deftypefun


@deftypefun void ccdoubles_real_vector_floor (size_t @var{nslots}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{floor}.
@end deftypefun


@deftypefun void ccdoubles_real_vector_trunc (size_t @var{nslots}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{trunc}.
@end deftypefun


@deftypefun void ccdoubles_real_vector_round (size_t @var{nslots}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{round}.
@end deftypefun


@deftypefun void ccdoubles_real_vector_rint (size_t @var{nslots}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{rint}.
@end deftypefun

@c page
@node vectors real special
@subsection Special real vector operations


@deftypefun double ccdoubles_real_vector_scalar_product (size_t @var{nslots}, const double * @vari{operand}, const double * @varii{operand})
Perform the scalar product between the operands and return the result.
The implementation is:

@example
double        result = 0.0;
for (size_t i=0; i<nslots; ++i) @{
  result += operand1[i] * operand2[i];
@}
@end example
@end deftypefun


@deftypefun void ccdoubles_real_vector_scalar_mul (size_t @var{nslots}, double * @var{result}, double @var{lambda}, const double * @var{operand})
Multiply the scalar @var{lambda} with all the slots in the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_linear_combination (size_t @var{nslots}, double * @var{result}, double @var{alpha}, double * @vari{operand}, double @var{beta}, double * @varii{operand})
Perform the linear combination of the vector operands and the given
scalars.  The implementation is:

@example
for (size_t i=0; i<nslots; ++i) @{
  result[i] = alpha * operand1[i] + beta * operand2[i];
@}
@end example
@end deftypefun

@c page
@node vectors real trigonometric
@subsection Trigonometric real vector operations


@deftypefun void ccdoubles_real_vector_sin (size_t @var{nslots}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_vector_cos (size_t @var{nslots}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_vector_tan (size_t @var{nslots}, double * @var{result}, double * @var{operand})
Compute slot--by--slot the trigonometric sine, cosine, tangent of the
operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_asin (size_t @var{nslots}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_vector_acos (size_t @var{nslots}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_vector_atan (size_t @var{nslots}, double * @var{result}, double * @var{operand})
Compute slot--by--slot the trigonometric arc sine, arc cosine, arc
tangent of the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_atan2 (size_t @var{nslots}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
Compute slot--by--slot the trigonometric arc tangent of the operands.
The implementation is:

@example
for (size_t i=0; i<nslots; ++i) @{
  result[i] = atan2(operand1[i], operand2[i]);
@}
@end example

@glibcref{Inverse Trig Functions, atan2} for details on @cfunc{atan2}.
@end deftypefun

@c page
@node vectors real hyperbolic
@subsection Hyperbolic real vector operations


@deftypefun void ccdoubles_real_vector_sinh (size_t @var{nslots}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_vector_cosh (size_t @var{nslots}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_vector_tanh (size_t @var{nslots}, double * @var{result}, double * @var{operand})
Compute slot--by--slot the hyperbolic sine, cosine, tangent of the
operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_asinh (size_t @var{nslots}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_vector_acosh (size_t @var{nslots}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_vector_atanh (size_t @var{nslots}, double * @var{result}, double * @var{operand})
Compute slot--by--slot the hyperbolic arc sine, arc cosine, arc tangent
of the operand.
@end deftypefun

@c page
@node vectors cplx
@section Operations on complex--valued vectors


@menu
* vectors cplx basic::          Basic complex vector operations.
* vectors cplx arithmetic::     Arithmetic complex vector operations.
* vectors cplx special::        Special complex vector operations.
* vectors cplx trigonometric::  Trigonometric complex vector operations.
* vectors cplx hyperbolic::     Hyperbolic complex vector operations.
@end menu

@c page
@node vectors cplx basic
@subsection Basic complex vector operations


@deftypefun void ccdoubles_cplx_vector_clear (size_t @var{nslots}, double complex * @var{vector})
Reset all the slots to complex numbers with real part @code{0.0} and
complex part @code{0.0}.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_set (size_t @var{nslots}, double complex * @var{vector}, double @var{value})
Set all the slots to the given @var{value}.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_copy (size_t @var{nslots}, double complex * @var{dst}, double complex * @var{src})
Copy the slots from @var{src} to @var{dst}.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void ccdoubles_cplx_vector_real (size_t @var{nslots}, double * @var{result}, double complex * @var{operand})
Extract slot--by--slot the real part of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_imag (size_t @var{nslots}, double * @var{result}, double complex * @var{operand})
Extract slot--by--slot the imaginary part of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_magnitude (size_t @var{nslots}, double * @var{result}, double complex * @var{operand})
Extract slot--by--slot the magnitude of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_angle (size_t @var{nslots}, double * @var{result}, double complex * @var{operand})
Extract slot--by--slot the angle of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_conj (size_t @var{nslots}, double complex * @var{result}, double complex * @var{operand})
Compute slot--by--slot the conjugate of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_from_rect (size_t @var{nslots}, double complex * @var{result}, double * @var{real}, double * imag)
Build slot--by--slot a complex valued vectors from the real and
imaginary parts.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_from_polar (size_t @var{nslots}, double complex * @var{result}, double * @var{magnitude}, double * @var{angle})
Build slot--by--slot a complex valued vectors from the magnitude and
angle.
@end deftypefun

@c page
@node vectors cplx arithmetic
@subsection Arithmetic complex vector operations


@deftypefun void ccdoubles_cplx_vector_add (size_t @var{nslots}, double complex * @var{result}, double complex * @vari{operand}, double complex * @varii{operand})
@deftypefunx void ccdoubles_cplx_vector_sub (size_t @var{nslots}, double complex * @var{result}, double complex * @vari{operand}, double complex * @varii{operand})
@deftypefunx void ccdoubles_cplx_vector_mul (size_t @var{nslots}, double complex * @var{result}, double complex * @vari{operand}, double complex * @varii{operand})
@deftypefunx void ccdoubles_cplx_vector_div (size_t @var{nslots}, double complex * @var{result}, double complex * @vari{operand}, double complex * @varii{operand})
Perform slot--by--slot addition, subtraction, multiplication and
division.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_neg (size_t @var{nslots}, double complex * @var{result}, double complex * @var{operand})
Perform the slot--by--slot negation of the operand.
@end deftypefun

@c page
@node vectors cplx special
@subsection Special complex vector operations


@deftypefun double ccdoubles_cplx_vector_scalar_product (size_t @var{nslots}, const double complex * @vari{operand}, const double complex * @varii{operand})
Perform the scalar product between the operands and return the result.
The implementation is:

@example
double complex  result = CCDOUBLES_CPLX(0.0, 0.0);
for (size_t i=0; i<nslots; ++i) @{
  result += operand1[i] * operand2[i];
@}
@end example
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_scalar_mul (size_t @var{nslots}, double complex * @var{result}, double @var{lambda}, const double complex * @var{operand})
Multiply the scalar @var{lambda} with all the slots in the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_linear_combination (size_t @var{nslots}, double complex * @var{result}, double @var{alpha}, double complex * @vari{operand}, double @var{beta}, double complex * @varii{operand})
Perform the linear combination of the vector operands and the given
scalars.  The implementation is:

@example
for (size_t i=0; i<nslots; ++i) @{
  result[i] = alpha * operand1[i] + beta * operand2[i];
@}
@end example
@end deftypefun

@c page
@node vectors cplx trigonometric
@subsection Trigonometric complex vector operations


@deftypefun void ccdoubles_cplx_vector_sin (size_t @var{nslots}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_vector_cos (size_t @var{nslots}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_vector_tan (size_t @var{nslots}, double complex * @var{result}, double complex * @var{operand})
Compute slot--by--slot the trigonometric sine, cosine, tangent of the
operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_asin (size_t @var{nslots}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_vector_acos (size_t @var{nslots}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_vector_atan (size_t @var{nslots}, double complex * @var{result}, double complex * @var{operand})
Compute slot--by--slot the trigonometric arc sine, arc cosine, arc
tangent of the operand.
@end deftypefun

@c page
@node vectors cplx hyperbolic
@subsection Hyperbolic complex vector operations


@deftypefun void ccdoubles_cplx_vector_sinh (size_t @var{nslots}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_vector_cosh (size_t @var{nslots}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_vector_tanh (size_t @var{nslots}, double complex * @var{result}, double complex * @var{operand})
Compute slot--by--slot the hyperbolic sine, cosine, tangent of the
operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_asinh (size_t @var{nslots}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_vector_acosh (size_t @var{nslots}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_vector_atanh (size_t @var{nslots}, double complex * @var{result}, double complex * @var{operand})
Compute slot--by--slot the hyperbolic arc sine, arc cosine, arc tangent
of the operand.
@end deftypefun

@c page
@node matrices
@chapter Operations on matrices


@menu
* matrices intro::               Introduction to matrix operations.
* matrices real::                Operations on real--valued matrices.
* matrices cplx::                Operations on complex--valued matrices.
@end menu

@c page
@node matrices intro
@section Introduction to vector operations


The matrices on which @value{PACKAGE} operates are meant to be
contiguous arrays of @code{double} and @code{double complex} stored in
row--major order, defined as follows:

@example
#include <ccdoubles.h>
#undef NROWS
#undef NCOLS
#define NROWS          2
#define NCOLS          2

double          RM[NROWS][NCOLS] = @{
  @{ 1.2, 3.4 @},  /* this is 1st row */
  @{ 5.6, 7.8 @}   /* this is 2nd row*/
@};
double complex  CM[NROWS][NCOLS] = @{
  @{ CCDOUBLES_CPLX(1.2, 2.3), CCDOUBLES_CPLX(3.4, 4.5) @},
  @{ CCDOUBLES_CPLX(5.6, 6.7), CCDOUBLES_CPLX(7.8, 8.9) @}
@};
@end example

@noindent
or as follows with dynamic size (which forbids hard--coded
initialisation of slots):

@example
size_t          nrows = 3;
size_t          ncols = 4;
double          RM[nrows][ncols];
double complex  CM[nrows][ncols];
@end example

All the matrix functions have simple implementation based on the
corresponding vector function; examples for real valued matrices:

@example
void
ccdoubles_real_matrix_add (size_t nrows, size_t ncols,
                           double * restrict result,
                           double * restrict operand1,
                           double * restrict operand2)
@{
  ccdoubles_real_vector_add (nrows * ncols, result,
                             operand1, operand2);
@}
void
ccdoubles_real_matrix_sin (size_t nrows, size_t ncols,
                           double * restrict result,
                           double * restrict operand)
@{
  ccdoubles_real_vector_sin (nrows * ncols, result, operand);
@}
@end example

@noindent
examples for complex valued matrices:

@example
void
ccdoubles_cplx_matrix_add (size_t nrows, size_t ncols,
			   double complex * restrict result,
			   double complex * restrict operand1,
			   double complex * restrict operand2)
@{
  ccdoubles_cplx_vector_add (nrows * ncols,
                             result, operand1, operand2);
@}
void
ccdoubles_cplx_matrix_sin (size_t nrows, size_t ncols,
			   double complex * restrict result,
			   double complex * restrict operand)
@{
  ccdoubles_cplx_vector_sin (nrows * ncols, result, operand);
@}
@end example

@value{PACKAGE} functions can be called as follows, see how the arrays
are passed as arguments:

@example
#include <ccdoubles.h>
#undef NROWS
#undef NCOLS
#define NROWS          2
#define NCOLS          2

double  M[NROWS][NCOLS] = @{
  @{ 1.2, 3.4 @},
  @{ 5.6, 7.8 @}
@};
double  R[NROWS][NCOLS];

ccdoubles_real_matrix_sin(NROWS, NCOLS, &R[0][0], &M[0][0]);
@end example

@noindent
the result is stored the array referenced by @code{R}, overwriting the
old contents.

@c page
@node matrices real
@section Operations on real--valued matrices


@menu
* matrices real basic::          Basic real matrix operations.
* matrices real arithmetic::     Arithmetic real matrix operations.
* matrices real rounding::       Rounding real matrix operations.
* matrices real special::        Special real matrix operations.
* matrices real trigonometric::  Trigonometric real matrix operations.
* matrices real hyperbolic::     Hyperbolic real matrix operations.
@end menu

@c page
@node matrices real basic
@subsection Basic real matrix operations


@deftypefun void ccdoubles_real_matrix_clear (size_t @var{nrows}, size_t @var{ncols}, double * @var{matrix})
Reset all the slots to @code{0.0}.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_set (size_t @var{nrows}, size_t @var{ncols}, double * @var{matrix}, double @var{value})
Set all the slots to the given @var{value}.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_copy (size_t @var{nrows}, size_t @var{ncols}, double * @var{dst}, double * @var{src})
Copy the slots from @var{src} to @var{dst}.
@end deftypefun

@c page
@node matrices real arithmetic
@subsection Arithmetic real matrix operations


@deftypefun void ccdoubles_real_matrix_add (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
@deftypefunx void ccdoubles_real_matrix_sub (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
@deftypefunx void ccdoubles_real_matrix_mul (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
@deftypefunx void ccdoubles_real_matrix_div (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
Perform slot--by--slot addition, subtraction, multiplication and
division.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_neg (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double * @var{operand})
Perform the slot--by--slot negation of the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_abs (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double * @var{operand})
Compute slot--by--slot the absolute value of the operand.
@end deftypefun

@c page
@node matrices real rounding
@subsection Rounding real matrix operations


@deftypefun void ccdoubles_real_matrix_ceil (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{ceil}.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_floor (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{floor}.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_trunc (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{trunc}.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_round (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{round}.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_rint (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{rint}.
@end deftypefun

@c page
@node matrices real special
@subsection Special real matrix operations


@deftypefun void ccdoubles_real_matrix_scalar_mul (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double @var{lambda}, const double * @var{operand})
Multiply the scalar @var{lambda} with all the slots in the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_linear_combination (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double @var{alpha}, double * @vari{operand}, double @var{beta}, double * @varii{operand})
Perform the linear combination of the matrix operands and the given
scalars.  The implementation is equivalent to:

@example
for (size_t i=0; i<nrows; ++i) @{
  for (size_t j=0; j<ncols; ++j) @{
    result[i][j] = \
      alpha * operand1[i][j] + \
      beta  * operand2[i][j];
  @}
@}
@end example
@end deftypefun

@c page
@node matrices real trigonometric
@subsection Trigonometric real matrix operations


@deftypefun void ccdoubles_real_matrix_sin (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_matrix_cos (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_matrix_tan (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double * @var{operand})
Compute slot--by--slot the trigonometric sine, cosine, tangent of the
operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_asin (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_matrix_acos (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_matrix_atan (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double * @var{operand})
Compute slot--by--slot the trigonometric arc sine, arc cosine, arc
tangent of the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_atan2 (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
Compute slot--by--slot the trigonometric arc tangent of the operands.
The implementation is equivalent to:

@example
for (size_t i=0; i<nrows; ++i) @{
  for (size_t j=0; i<ncols; ++j) @{
    result[i][j] = atan2(operand1[i][j], operand2[i][j]);
  @}
@}
@end example

@glibcref{Inverse Trig Functions, atan2} for details on @cfunc{atan2}.
@end deftypefun

@c page
@node matrices real hyperbolic
@subsection Hyperbolic real matrix operations


@deftypefun void ccdoubles_real_matrix_sinh (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_matrix_cosh (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_matrix_tanh (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double * @var{operand})
Compute slot--by--slot the hyperbolic sine, cosine, tangent of the
operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_asinh (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_matrix_acosh (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_matrix_atanh (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double * @var{operand})
Compute slot--by--slot the hyperbolic arc sine, arc cosine, arc tangent
of the operand.
@end deftypefun

@c page
@node matrices cplx
@section Operations on complex--valued matrices


@menu
* matrices cplx basic::          Basic complex matrix operations.
* matrices cplx arithmetic::     Arithmetic complex matrix operations.
* matrices cplx special::        Special complex matrix operations.
* matrices cplx trigonometric::  Trigonometric complex matrix operations.
* matrices cplx hyperbolic::     Hyperbolic complex matrix operations.
@end menu

@c page
@node matrices cplx basic
@subsection Basic complex matrix operations


@deftypefun void ccdoubles_cplx_matrix_clear (size_t @var{nrows}, size_t @var{ncols}, double complex * @var{matrix})
Reset all the slots to complex numbers with real part @code{0.0} and
complex part @code{0.0}.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_set (size_t @var{nrows}, size_t @var{ncols}, double complex * @var{matrix}, double complex @var{value})
Set all the slots to the given @var{value}.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_copy (size_t @var{nrows}, size_t @var{ncols}, double complex * @var{dst}, double complex * @var{src})
Copy the slots from @var{src} to @var{dst}.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void ccdoubles_cplx_matrix_real (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double complex * @var{operand})
Extract slot--by--slot the real part of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_imag (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double complex * @var{operand})
Extract slot--by--slot the imaginary part of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_magnitude (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double complex * @var{operand})
Extract slot--by--slot the magnitude of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_angle (size_t @var{nrows}, size_t @var{ncols}, double * @var{result}, double complex * @var{operand})
Extract slot--by--slot the angle of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_conj (size_t @var{nrows}, size_t @var{ncols}, double complex * @var{result}, double complex * @var{operand})
Compute slot--by--slot the conjugate of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_from_rect (size_t @var{nrows}, size_t @var{ncols}, double complex * @var{result}, double * @var{real}, double * imag)
Build slot--by--slot a complex valued matrix from the real and imaginary
parts.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_from_polar (size_t @var{nrows}, size_t @var{ncols}, double complex * @var{result}, double * @var{magnitude}, double * @var{angle})
Build slot--by--slot a complex valued matrix from the magnitude and
angle.
@end deftypefun

@c page
@node matrices cplx arithmetic
@subsection Arithmetic complex matrix operations


@deftypefun void ccdoubles_cplx_matrix_add (size_t @var{nrows}, size_t @var{ncols}, double complex * @var{result}, double complex * @vari{operand}, double complex * @varii{operand})
@deftypefunx void ccdoubles_cplx_matrix_sub (size_t @var{nrows}, size_t @var{ncols}, double complex * @var{result}, double complex * @vari{operand}, double complex * @varii{operand})
@deftypefunx void ccdoubles_cplx_matrix_mul (size_t @var{nrows}, size_t @var{ncols}, double complex * @var{result}, double complex * @vari{operand}, double complex * @varii{operand})
@deftypefunx void ccdoubles_cplx_matrix_div (size_t @var{nrows}, size_t @var{ncols}, double complex * @var{result}, double complex * @vari{operand}, double complex * @varii{operand})
Perform slot--by--slot addition, subtraction, multiplication and
division.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_neg (size_t @var{nrows}, size_t @var{ncols}, double complex * @var{result}, double complex * @var{operand})
Perform the slot--by--slot negation of the operand.
@end deftypefun

@c page
@node matrices cplx special
@subsection Special complex matrix operations


@deftypefun void ccdoubles_cplx_matrix_scalar_mul (size_t @var{nrows}, size_t @var{ncols}, double complex * @var{result}, double @var{lambda}, const double complex * @var{operand})
Multiply the scalar @var{lambda} with all the slots in the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_linear_combination (size_t @var{nrows}, size_t @var{ncols}, double complex * @var{result}, double complex @var{alpha}, double complex * @vari{operand}, double complex @var{beta}, double complex * @varii{operand})
Perform the linear combination of the matrix operands and the given
scalars.  The implementation is equivalent to:

@example
for (size_t i=0; i<nrows; ++i) @{
  for (size_t j=0; j<ncols; ++j) @{
    result[i][j] = \
      alpha * operand1[i][j] + \
      beta  * operand2[i][j];
  @}
@}
@end example
@end deftypefun

@c page
@node matrices cplx trigonometric
@subsection Trigonometric complex matrix operations


@deftypefun void ccdoubles_cplx_matrix_sin (size_t @var{nrows}, size_t @var{ncols}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_matrix_cos (size_t @var{nrows}, size_t @var{ncols}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_matrix_tan (size_t @var{nrows}, size_t @var{ncols}, double complex * @var{result}, double complex * @var{operand})
Compute slot--by--slot the trigonometric sine, cosine, tangent of the
operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_asin (size_t @var{nrows}, size_t @var{ncols}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_matrix_acos (size_t @var{nrows}, size_t @var{ncols}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_matrix_atan (size_t @var{nrows}, size_t @var{ncols}, double complex * @var{result}, double complex * @var{operand})
Compute slot--by--slot the trigonometric arc sine, arc cosine, arc
tangent of the operand.
@end deftypefun

@c page
@node matrices cplx hyperbolic
@subsection Hyperbolic complex matrix operations


@deftypefun void ccdoubles_cplx_matrix_sinh (size_t @var{nrows}, size_t @var{ncols}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_matrix_cosh (size_t @var{nrows}, size_t @var{ncols}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_matrix_tanh (size_t @var{nrows}, size_t @var{ncols}, double complex * @var{result}, double complex * @var{operand})
Compute slot--by--slot the hyperbolic sine, cosine, tangent of the
operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_asinh (size_t @var{nrows}, size_t @var{ncols}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_matrix_acosh (size_t @var{nrows}, size_t @var{ncols}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_matrix_atanh (size_t @var{nrows}, size_t @var{ncols}, double complex * @var{result}, double complex * @var{operand})
Compute slot--by--slot the hyperbolic arc sine, arc cosine, arc tangent
of the operand.
@end deftypefun

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include gpl-3.0.texi
@include fdl-1.3.texi

@c page
@node resources
@appendix On--line resources


The latest version of this package can be downloaded from:

@center @url{http://github.com/marcomaggi/@value{PACKAGE_NICKNAME}/}

@noindent
the documentation is available online:

@center @url{http://marcomaggi.github.com/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@node references
@appendix Bibliography and references



@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

