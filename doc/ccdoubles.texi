\input texinfo.tex
@c %**start of header
@setfilename ccdoubles.info
@settitle CCDoubles
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCDoubles

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCDoubles

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ccdoubles

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2014

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a
C99 language library implementing simple routines for vectors and
matrices of @code{double} and @code{double complex} values.  The package
is distributed under the terms of the @gnu{} General Public License
(@gpl{}).

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with
Invariant Sections being ``@gnu{} Free Documentation License'' and
``@gnu{} General Public License'', no Front--Cover Texts, and no
Back--Cover Texts.  A copy of the license is included in the section
entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ccdoubles: (ccdoubles).       CCDoubles.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* scalars::                     Operations on scalar numbers.
* vectors::                     Operations on vectors.
* matrices::                    Operations on matrices.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* resources::                   On--line resources.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a
C99 language library implementing simple routines for vectors and
matrices of @code{double} and @code{double complex} values.  This
library is meant to be used as companion for more sophisticated
libraries such as @acronym{CBLAS} and @acronym{LAPACKE}.

@value{PACKAGE} installs the single header file @file{ccdoubles.h}.  All
the function names in the @api{} are prefixed with @code{ccdoubles_};
all the preprocessor macro names are prefixed with @code{CCDOUBLES_};
all the type names are prefixed with @code{ccdoubles_} and suffixed with
@code{_t}.

@menu
* overview linking::            Linking code with the library.
@end menu

@c page
@node overview linking
@section Linking code with the library


This package installs a data file for @command{pkg-config}, so when
searching for the installed library with the @gnu{} Autotools, we can:

@itemize
@item
Install the file @file{pkg.m4} from @file{/usr/share/aclocal} into the
source tree of the package, for example under @file{meta/autoconf/}.

@item
Include @file{pkg.m4} in the template by adding the following line to
@file{acinclude.m4}:

@example
m4_include(meta/autoconf/pkg.m4)
@end example

@item
Just add the following macro use to @file{configure.ac}:

@example
PKG_CHECK_MODULES([CCDOUBLES],[ccdoubles >= 0.1])
@end example

@noindent
which will set the variables @code{CCDOUBLES_LIBS} and
@code{CCDOUBLES_CFLAGS}.
@end itemize

Alternatively we can use the raw @gnu{} Autoconf macros:

@example
AC_CHECK_LIB([ccdoubles],[ccd_version_string],,
  [AC_MSG_FAILURE([test for CCDoubles library failed])])
AC_CHECK_HEADERS([ccdoubles.h],,
  [AC_MSG_FAILURE([test for CCDoubles header failed])])
@end example

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the
@gnu{} Autotools.  For an explanation of interface numbers as managed by
@gnu{} Libtool @xref{Libtool versioning, interface, Libtool's versioning
system, libtool, Shared library support for @gnu{}}.


@deftypefun {const char *} ccdoubles_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing
the interface version number.
@end deftypefun


@deftypefun int ccdoubles_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int ccdoubles_version_interface_revision (void)
Return an integer representing the library interface current revision
number.
@end deftypefun


@deftypefun int ccdoubles_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node scalars
@chapter Operations on scalar numbers


@menu
* scalars complex::             Operations on scalar complex numbers.
@end menu

@c page
@node scalars complex
@section Operations on scalar complex numbers


@menu
* scalars complex funcs::       Functions acting on scalar complex values.
* scalars complex macros::      Preprocessor macros.
@end menu

@c page
@node scalars complex funcs
@subsection Functions acting on scalar complex values


The C99 language standard library defines common operations on scalar
@code{double complex} numbers; in addition @value{PACKAGE} defines
convenience functions to perform the same.


@deftypefun {double complex} ccdoubles_cplx_mul (double complex @vari{O}, double complex @varii{O})
Even though C99 supports the multiplication operation as:

@example
#include <ccdoubles.h>

double complex  O1 = CCDOUBLES_CPLX(1.2, 3.4);
double complex  O2 = CCDOUBLES_CPLX(5.6, 7.8);
double complex  R  = O1 * O2;

printf("R = %lf%+lfi\n", creal(R), cimag(R));
@print{} R = -19.800000+28.400000i
@end example

@noindent
this function computes and returns the product between the operands.
Example:

@example
#include <ccdoubles.h>

double complex  O1 = CCDOUBLES_CPLX(1.2, 3.4);
double complex  O2 = CCDOUBLES_CPLX(5.6, 7.8);
double complex  R;

R = ccdoubles_cplx_mul(O1, O2);

printf("R = %lf%+lfi\n", creal(R), cimag(R));
@print{} R = -19.800000+28.400000i
@end example
@end deftypefun


@deftypefun {double complex} ccdoubles_cplx_div (double complex @vari{O}, double complex @varii{O})
Even though C99 supports the division operation as:

@example
#include <ccdoubles.h>

double complex  O1 = CCDOUBLES_CPLX(1.2, 3.4);
double complex  O2 = CCDOUBLES_CPLX(5.6, 7.8);
double complex  R  = O1 / O2;

printf("R = %lf%+lfi\n", creal(R), cimag(R));
@print{} R = 0.360521+0.104989i
@end example

@noindent
this function computes and returns the division between the operands.
Example:

@example
#include <ccdoubles.h>

double complex  O1 = CCDOUBLES_CPLX(1.2, 3.4);
double complex  O2 = CCDOUBLES_CPLX(5.6, 7.8);
double complex  R;

R = ccdoubles_cplx_div(O1, O2);

printf("R = %lf%+lfi\n", creal(R), cimag(R));
@print{} R = 0.360521+0.104989i
@end example
@end deftypefun


@deftypefun {double complex} ccdoubles_cplx_neg (double complex @var{O})
Even though C99 supports the negation operation as:

@example
#include <ccdoubles.h>

double complex  O = CCDOUBLES_CPLX(1.2, 3.4);
double complex  R = - O;

printf("R = %lf%+lfi\n", creal(R), cimag(R));
@print{} R = -1.200000-3.400000i
@end example

@noindent
this function computes and returns the negation of the operand.
Example:

@example
#include <ccdoubles.h>

double complex  O = CCDOUBLES_CPLX(1.2, 3.4);
double complex  R;

R = ccdoubles_cplx_neg(O);

printf("R = %lf%+lfi\n", creal(R), cimag(R));
@print{} R = -1.200000-3.400000i
@end example
@end deftypefun


@c page
@node scalars complex macros
@subsection Preprocessor macros


@deftypefn {Preprocessor Macro} {double complex} CCDOUBLES_CPLX (double @var{REAL}, double @var{IMAG})
Build and return a new @code{double complex} value.  Expands into:

@example
(((double)(@var{REAL})) + ((double)(@var{IMAG})) * _Complex_I)
@end example

@quotation
@strong{NOTE} The latest C Language Standard defines the same operation
with the preprocessor macro @code{CMPLX(@var{REAL}, @var{IMAG})}.
@end quotation
@end deftypefn


@deftypefn {Preprocessor Macro} {double complex} Z (double @var{real}, double @var{imag})
Return a new @code{double complex}.

This macro is an alias for @func{CCDOUBLES_CPLX} but it is defined only
if the header @file{ccdoubles.h} is included with the C preprocessor
symbol @code{CCDOUBLES_ENABLE_SHORT_MACROS} already defined.
@end deftypefn


@deftypefn {Preprocessor Macro} double Re (double complex @var{Z})
@deftypefnx {Preprocessor Macro} double Im (double complex @var{Z})
Return the real or imaginary part of the complex number @var{Z} by
applying @func{creal} or @func{cimag} to it.

This macro is defined only if the header @file{ccdoubles.h} is included
with the C preprocessor symbol @code{CCDOUBLES_ENABLE_SHORT_MACROS}
already defined.
@end deftypefn


@deftypefn {Preprocessor Macro} {double *} MREF (@var{M})
Expand into a pointer to the first element of a bidimensional array:

@example
MREF(M) @expansion{} &M[0][0]
@end example

This macro is defined only if the header @file{ccdoubles.h} is included
with the C preprocessor symbol @code{CCDOUBLES_ENABLE_SHORT_MACROS}
already defined.
@end deftypefn

@c page
@node vectors
@chapter Operations on vectors


@menu
* vectors intro::               Introduction to vector operations.
* vectors real::                Operations on real--valued vectors.
* vectors cplx::                Operations on complex--valued vectors.
* vectors int::                 Operations on @code{int}--valued vectors.
@end menu

@c page
@node vectors intro
@section Introduction to vector operations


The vectors on which @value{PACKAGE} operates are meant to be contiguous
arrays of @code{double} and @code{double complex} values, defined as
follows:

@example
#include <ccdoubles.h>
#undef NSLOTS
#define NSLOTS          2

double          RV[NSLOTS] = @{ 1.2, 3.4 @};
double complex  CV[NSLOTS] = @{
  CCDOUBLES_CPLX(1.2, 3.4),
  CCDOUBLES_CPLX(5.6, 7.8)
@};
@end example

@noindent
or as follows with dynamic size (which forbids hard--coded
initialisation of slots):

@example
unsigned        nslots = 1;
double          RV[nslots];
double complex  CV[nslots];
@end example

The memory layout of a vector is equal to the memory layout of a matrix
with a single row defined as follows:

@example
unsigned        nrows = 1;
unsigned        ncols = 3;
double          RM[nrows][ncols];
double complex  CM[nrows][ncols];
@end example

@noindent
and equal to the memory layout of a matrix with a single column defined
as follows:

@example
unsigned        nrows = 3;
unsigned        ncols = 1;
double          RM[nrows][ncols];
double complex  CM[nrows][ncols];
@end example

All the functions have simple implementation involving an iteration over
the vector's slots using @code{restrict} pointers; examples for real
valued vectors:

@example
void
ccdoubles_real_vector_add (unsigned nslots,
                           double * restrict result,
                           double * restrict operand1,
                           double * restrict operand2)
@{
  for (unsigned i=0; i<nslots; ++i) @{
    result[i] = operand1[i] + operand2[i];
  @}
@}
void
ccdoubles_real_vector_sin (unsigned nslots,
                           double * restrict result,
                           double * restrict operand)
@{
  for (unsigned i=0; i<nslots; ++i) @{
    result[i] = sin(operand[i]);
  @}
@}
@end example

@noindent
examples for complex valued vectors:

@example
void
ccdoubles_cplx_vector_add (unsigned nslots,
                           double complex * restrict result,
                           double complex * restrict operand1,
                           double complex * restrict operand2)
@{
  for (unsigned i=0; i<nslots; ++i) @{
    result[i] = operand1[i] + operand2[i];
  @}
@}
void
ccdoubles_cplx_vector_sin (unsigned nslots,
                           double complex * restrict result,
                           double complex * restrict operand)
@{
  for (unsigned i=0; i<nslots; ++i) @{
    result[i] = csin(operand[i]);
  @}
@}
@end example

@value{PACKAGE} functions can be called as follows, see how the arrays
are passed as arguments:

@example
#include <ccdoubles.h>
#undef NSLOTS
#define NSLOTS         2

double  V[NSLOTS] = @{ 1.2, 3.4 @};
double  R[NSLOTS];

ccdoubles_real_vector_sin(NROWS, NCOLS, R, V);
@end example

@noindent
the result is stored the array referenced by @code{R}, overwriting the
old contents.

@c page
@node vectors real
@section Operations on real--valued vectors


@menu
* vectors real basic::          Basic real vector operations.
* vectors real arithmetic::     Arithmetic real vector operations.
* vectors real rounding::       Rounding real vector operations.
* vectors real comparison::     Comparing real vectors.
* vectors real predicates::     Inspecting real vectors.
* vectors real special::        Special real vector operations.
* vectors real explog::         Real vector exponentiation and
                                logarithms.
* vectors real trigonometric::  Trigonometric real vector operations.
* vectors real hyperbolic::     Hyperbolic real vector operations.
* vectors real printing::       Printing real vectors.
@end menu

@c page
@node vectors real basic
@subsection Basic real vector operations


@deftypefun void ccdoubles_real_vector_clear (unsigned @var{nslots}, double * @var{vector})
Reset all the slots to @code{0.0}.
@end deftypefun


@deftypefun void ccdoubles_real_vector_set (unsigned @var{nslots}, double * @var{vector}, double @var{value})
Set all the slots to the given @var{value}.
@end deftypefun


@deftypefun void ccdoubles_real_vector_copy (unsigned @var{nslots}, double * @var{dst}, double * @var{src})
Copy the slots from @var{src} to @var{dst}.
@end deftypefun

@c page
@node vectors real arithmetic
@subsection Arithmetic real vector operations


@deftypefun void ccdoubles_real_vector_add (unsigned @var{nslots}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
@deftypefunx void ccdoubles_real_vector_sub (unsigned @var{nslots}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
@deftypefunx void ccdoubles_real_vector_mul (unsigned @var{nslots}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
@deftypefunx void ccdoubles_real_vector_div (unsigned @var{nslots}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
Perform slot--by--slot addition, subtraction, multiplication and
division.
@end deftypefun


@deftypefun void ccdoubles_real_vector_neg (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
Perform the slot--by--slot negation of the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_abs (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
Compute slot--by--slot the absolute value of the operand.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void ccdoubles_real_vector_fmod (unsigned @var{nslots}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
Apply slot--by--slot the function @cfunc{fmod} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_vector_drem (unsigned @var{nslots}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
Apply slot--by--slot the function @cfunc{drem} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_vector_remainder (unsigned @var{nslots}, double * @var{result}, double * @vari{operand}, double *1 @varii{operand})
Apply slot--by--slot the function @cfunc{remainder} to the operands.
@end deftypefun

@c page
@node vectors real rounding
@subsection Rounding real vector operations


@deftypefun void ccdoubles_real_vector_ceil (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{ceil}.
@end deftypefun


@deftypefun void ccdoubles_real_vector_floor (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{floor}.
@end deftypefun


@deftypefun void ccdoubles_real_vector_trunc (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{trunc}.
@end deftypefun


@deftypefun void ccdoubles_real_vector_round (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{round}.
@end deftypefun


@deftypefun void ccdoubles_real_vector_rint (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{rint}.
@end deftypefun

@c page
@node vectors real comparison
@subsection Comparing real vectors


@deftypefun void ccdoubles_real_vector_isgreater (unsigned @var{nslots}, int * @var{result}, double * @vari{operand}, double * @varii{operand})
Apply slot--by--slot the function @cfunc{isgreater} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_vector_isgreaterequal (unsigned @var{nslots}, int * @var{result}, double * @vari{operand}, double * @varii{operand})
Apply slot--by--slot the function @cfunc{isgreaterequal} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_vector_isless (unsigned @var{nslots}, int * @var{result}, double * @vari{operand}, double * @varii{operand})
Apply slot--by--slot the function @cfunc{isless} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_vector_islessequal (unsigned @var{nslots}, int * @var{result}, double * @vari{operand}, double * @varii{operand})
Apply slot--by--slot the function @cfunc{islessequal} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_vector_islessgreater (unsigned @var{nslots}, int * @var{result}, double * @vari{operand}, double * @varii{operand})
Apply slot--by--slot the function @cfunc{islessgreater} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_vector_isunordered (unsigned @var{nslots}, int * @var{result}, double * @vari{operand}, double * @varii{operand})
Apply slot--by--slot the function @cfunc{isunordered} to the operands.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void ccdoubles_real_vector_min (unsigned @var{nslots}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
Apply slot--by--slot the function @cfunc{fmin} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_vector_max (unsigned @var{nslots}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
Apply slot--by--slot the function @cfunc{fmax} to the operands.
@end deftypefun

@c page
@node vectors real predicates
@subsection Inspecting real vectors


@deftypefun void ccdoubles_real_vector_fpclassify (unsigned @var{nslots}, int * @var{result}, double * @var{operand})
Apply slot--by--slot the macro @cfunc{fpclassify} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_isfinite (unsigned @var{nslots}, int * @var{result}, double * @var{operand})
Apply slot--by--slot the macro @cfunc{isfinite} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_isinfinite (unsigned @var{nslots}, int * @var{result}, double * @var{operand})
Apply slot--by--slot the macro @cfunc{isinfinite} to the operand and
reverse the result.
@end deftypefun


@deftypefun void ccdoubles_real_vector_isnormal (unsigned @var{nslots}, int * @var{result}, double * @var{operand})
Apply slot--by--slot the macro @cfunc{isnormal} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_isnan (unsigned @var{nslots}, int * @var{result}, double * @var{operand})
Apply slot--by--slot the macro @cfunc{isnan} to the operand.
@end deftypefun

@c page
@node vectors real special
@subsection Special real vector operations


@deftypefun double ccdoubles_real_vector_scalar_product (unsigned @var{nslots}, const double * @vari{operand}, const double * @varii{operand})
Perform the scalar product between the operands and return the result.
The implementation is:

@example
double        result = 0.0;
for (unsigned i=0; i<nslots; ++i) @{
  result += operand1[i] * operand2[i];
@}
@end example
@end deftypefun


@deftypefun void ccdoubles_real_vector_scalar_mul (unsigned @var{nslots}, double * @var{result}, double @var{lambda}, const double * @var{operand})
Multiply the scalar @var{lambda} with all the slots in the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_linear_combination (unsigned @var{nslots}, double * @var{result}, double @var{alpha}, double * @vari{operand}, double @var{beta}, double * @varii{operand})
Perform the linear combination of the vector operands and the given
scalars.  The implementation is:

@example
for (unsigned i=0; i<nslots; ++i) @{
  result[i] = alpha * operand1[i] + beta * operand2[i];
@}
@end example
@end deftypefun


@deftypefun void ccdoubles_real_vector_linspace (unsigned @var{nslots}, double * @var{result}, double @var{start}, double @var{past})
Fill the result vector with @var{nslots} evenly--spaced steps from
@var{start} to @var{past}.  It is implemented as follows:

@example
double        step = (past - start) / ((double)nslots);
for (unsigned i=0; i<nslots; ++i) @{
  result[i] = ((double)i) * step + start;
@}
@end example

As example, the code:

@example
unsigned    nslots = 10;
double      R[nslots];
double      start = 0.0;
double      past  = 10.0;
ccdoubles_real_vector_linspace (nslots, R, start, past);
ccdoubles_real_vector_print_brackets(stdout, nslots, R);
@end example

@noindent
prints (edited to add newlines):

@example
[+0.000000 +1.000000 +2.000000 +3.000000
 +4.000000 +5.000000 +6.000000 +7.000000
 +8.000000 +9.000000]
@end example
@end deftypefun


@deftypefun void ccdoubles_real_vector_logspace (unsigned @var{nslots}, double * @var{result}, double @var{start}, double @var{past})
Fill the result vector with @var{nslots} logarithmically spaced steps
from @code{pow(10.0, @var{start})} to @code{pow(10.0, @var{past})}.  It
is implemented as follows:

@example
double        step = (past - start) / ((double)nslots);
for (unsigned i=0; i<nslots; ++i) @{
  result[i] = pow(10.0, ((double)i) * step + start);
@}
@end example

As example, the code:

@example
unsigned    nslots = 10;
double      R[nslots];
double      start = 0.0;
double      past  = 10.0;
ccdoubles_real_vector_logspace (nslots, R, start, past);
ccdoubles_real_vector_print_brackets(stdout, nslots, R);
@end example

@noindent
prints (edited to add newlines):

@example
[+1.000000
 +10.000000
 +100.000000
 +1000.000000
 +10000.000000
 +100000.000000
 +1000000.000000
 +10000000.000000
 +100000000.000000
 +1000000000.000000]
@end example
@end deftypefun

@c page
@node vectors real explog
@subsection Real vectors exponentiation and logarithms


@deftypefun void ccdoubles_real_vector_exp (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{exp} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_exp10 (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @code{exp(X * log(10))} to the
operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_exp2 (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{exp2} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_log (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{log} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_log10 (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{log10} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_log2 (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{log2} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_logb (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{logb} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_pow (unsigned @var{nslots}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
Apply slot--by--slot the function @cfunc{pow} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_sqrt (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{sqrt} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_cbrt (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{cbrt} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_hypot (unsigned @var{nslots}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
Apply slot--by--slot the function @cfunc{hypot} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_expm1 (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{expm1} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_log1p (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{log1p} to the operand.
@end deftypefun

@c page
@node vectors real trigonometric
@subsection Trigonometric real vector operations


@deftypefun void ccdoubles_real_vector_sin (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_vector_cos (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_vector_tan (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
Compute slot--by--slot the trigonometric sine, cosine, tangent of the
operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_asin (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_vector_acos (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_vector_atan (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
Compute slot--by--slot the trigonometric arc sine, arc cosine, arc
tangent of the operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_atan2 (unsigned @var{nslots}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
Compute slot--by--slot the trigonometric arc tangent of the operands.
The implementation is:

@example
for (unsigned i=0; i<nslots; ++i) @{
  result[i] = atan2(operand1[i], operand2[i]);
@}
@end example

@glibcref{Inverse Trig Functions, atan2} for details on @cfunc{atan2}.
@end deftypefun

@c page
@node vectors real hyperbolic
@subsection Hyperbolic real vector operations


@deftypefun void ccdoubles_real_vector_sinh (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_vector_cosh (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_vector_tanh (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
Compute slot--by--slot the hyperbolic sine, cosine, tangent of the
operand.
@end deftypefun


@deftypefun void ccdoubles_real_vector_asinh (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_vector_acosh (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_vector_atanh (unsigned @var{nslots}, double * @var{result}, double * @var{operand})
Compute slot--by--slot the hyperbolic arc sine, arc cosine, arc tangent
of the operand.
@end deftypefun

@c page
@node vectors real printing
@subsection Printing real vectors


@deftypefun void ccdoubles_real_vector_print_display (FILE * @var{f}, const char * @var{name}, unsigned @var{nslots}, double * @var{operand})
Print on @var{f} a layout of the operand.  @var{name} must be a pointer
to an @asciiz{} string representing the operand name.  Example:

@example
#undef NSLOTS
#define NSLOTS          3
double      O[NSLOTS] = @{ 1.1, 1.2, 1.3 @};
ccdoubles_real_vector_print_display(stdout, "O", NSLOTS, O);
@end example

@noindent
will print:

@smallexample
Vector O (dimension 3):
| (1) +1.100000 ; (2) +1.200000 ; (3) +1.300000 |
@end smallexample
@end deftypefun


@deftypefun void ccdoubles_real_vector_print_brackets (FILE * @var{f}, unsigned @var{nslots}, double * @var{operand})
Print on @var{f} a layout of the operand.  Example:

@example
#undef NSLOTS
#define NSLOTS          3
double      O[NSLOTS] = @{ 1.1, 1.2, 1.3 @};
ccdoubles_real_vector_print_brackets(stdout, NSLOTS, O);
@end example

@noindent
will print:

@smallexample
[+1.100000 +1.200000 +1.300000]
@end smallexample
@end deftypefun


@deftypefun void ccdoubles_real_vector_print_braces (FILE * @var{f}, unsigned @var{nslots}, double * @var{operand})
Print on @var{f} a layout of the operand.  Example:

@example
#undef NSLOTS
#define NSLOTS          3
double      O[NSLOTS] = @{ 1.1, 1.2, 1.3 @};
ccdoubles_real_vector_print_brackets(stdout, NSLOTS, O);
@end example

@noindent
will print:

@smallexample
@{+1.100000, +1.200000, +1.300000@}
@end smallexample
@end deftypefun

@c page
@node vectors cplx
@section Operations on complex--valued vectors


@menu
* vectors cplx basic::          Basic complex vector operations.
* vectors cplx arithmetic::     Arithmetic complex vector operations.
* vectors cplx special::        Special complex vector operations.
* vectors cplx explog::         Complex vectors exponentiation and
                                logarithms.
* vectors cplx trigonometric::  Trigonometric complex vector operations.
* vectors cplx hyperbolic::     Hyperbolic complex vector operations.
* vectors cplx printing::       Printing complex vectors.
@end menu

@c page
@node vectors cplx basic
@subsection Basic complex vector operations


@deftypefun void ccdoubles_cplx_vector_clear (unsigned @var{nslots}, double complex * @var{vector})
Reset all the slots to complex numbers with real part @code{0.0} and
complex part @code{0.0}.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_set (unsigned @var{nslots}, double complex * @var{vector}, double complex @var{value})
Set all the slots to the given @var{value}.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_set_split (unsigned @var{nslots}, double complex * @var{vector}, double @var{value_re}, double @var{value_im})
Set all the slots to a complex number having @var{value_re} as real part
and @var{value_im} as imaginary part.  This function is like
@cfunc{ccdoubles_cplx_vector_set}, but splitting the real and imaginary
parts makes it easier to interface it with foreign languages.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_copy (unsigned @var{nslots}, double complex * @var{dst}, double complex * @var{src})
Copy the slots from @var{src} to @var{dst}.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void ccdoubles_cplx_vector_real (unsigned @var{nslots}, double * @var{result}, double complex * @var{operand})
Extract slot--by--slot the real part of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_imag (unsigned @var{nslots}, double * @var{result}, double complex * @var{operand})
Extract slot--by--slot the imaginary part of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_magnitude (unsigned @var{nslots}, double * @var{result}, double complex * @var{operand})
Extract slot--by--slot the magnitude of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_angle (unsigned @var{nslots}, double * @var{result}, double complex * @var{operand})
Extract slot--by--slot the angle of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_conj (unsigned @var{nslots}, double complex * @var{result}, double complex * @var{operand})
Compute slot--by--slot the conjugate of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_from_rect (unsigned @var{nslots}, double complex * @var{result}, double * @var{real}, double * imag)
Build slot--by--slot a complex valued vectors from the real and
imaginary parts.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_from_polar (unsigned @var{nslots}, double complex * @var{result}, double * @var{magnitude}, double * @var{angle})
Build slot--by--slot a complex valued vectors from the magnitude and
angle.
@end deftypefun

@c page
@node vectors cplx arithmetic
@subsection Arithmetic complex vector operations


@deftypefun void ccdoubles_cplx_vector_add (unsigned @var{nslots}, double complex * @var{result}, double complex * @vari{operand}, double complex * @varii{operand})
@deftypefunx void ccdoubles_cplx_vector_sub (unsigned @var{nslots}, double complex * @var{result}, double complex * @vari{operand}, double complex * @varii{operand})
@deftypefunx void ccdoubles_cplx_vector_mul (unsigned @var{nslots}, double complex * @var{result}, double complex * @vari{operand}, double complex * @varii{operand})
@deftypefunx void ccdoubles_cplx_vector_div (unsigned @var{nslots}, double complex * @var{result}, double complex * @vari{operand}, double complex * @varii{operand})
Perform slot--by--slot addition, subtraction, multiplication and
division.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_neg (unsigned @var{nslots}, double complex * @var{result}, double complex * @var{operand})
Perform the slot--by--slot negation of the operand.
@end deftypefun

@c page
@node vectors cplx special
@subsection Special complex vector operations


@deftypefun double ccdoubles_cplx_vector_scalar_product (unsigned @var{nslots}, const double complex * @vari{operand}, const double complex * @varii{operand})
Perform the scalar product between the operands and return the result.
The implementation is:

@example
double complex  result = CCDOUBLES_CPLX(0.0, 0.0);
for (unsigned i=0; i<nslots; ++i) @{
  result += operand1[i] * operand2[i];
@}
@end example
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_scalar_mul (unsigned @var{nslots}, double complex * @var{result}, double complex @var{lambda}, const double complex * @var{operand})
Multiply the scalar @var{lambda} with all the slots in the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_scalar_mul_split (unsigned @var{nslots}, double complex * @var{result}, double @var{lambda_re}, double @var{lambda_im}, const double complex * @var{operand})
Multiply the scalar having real part @var{lambda_re} and imaginary part
@var{lambda_im} with all the slots in the operand.  This function is
like @cfunc{ccdoubles_cplx_vector_scalar_mul}, but splitting the real
and imaginary parts makes it easier to interface it with foreign
languages.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_linear_combination (unsigned @var{nslots}, double complex * @var{result}, double complex @var{alpha}, double complex * @vari{operand}, double complex @var{beta}, double complex * @varii{operand})
Perform the linear combination of the vector operands and the given
scalars.  The implementation is:

@example
for (unsigned i=0; i<nslots; ++i) @{
  result[i] = alpha * operand1[i] + beta * operand2[i];
@}
@end example
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_linear_combination_split (unsigned @var{nslots}, double complex * @var{result}, double @var{alpha_re}, double @var{alpha_im}, double complex * @vari{operand}, double @var{beta_re}, double @var{beta_im}, double complex * @varii{operand})
Perform the linear combination of the vector operands and the given
scalars.  This function is like
@cfunc{ccdoubles_cplx_vector_linear_combination}, but splitting the real
and imaginary parts of the coefficients makes it easier to interface it
with foreign languages.
@end deftypefun

@c page
@node vectors cplx explog
@subsection Complex vectors exponentiation and logarithms


@deftypefun void ccdoubles_cplx_vector_exp (unsigned @var{nslots}, double complex * @var{result}, double complex * @var{operand})
Apply slot--by--slot the function @cfunc{cexp} to the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_log (unsigned @var{nslots}, double complex * @var{result}, double complex * @var{operand})
Apply slot--by--slot the function @cfunc{clog} to the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_log10 (unsigned @var{nslots}, double complex * @var{result}, double complex * @var{operand})
Apply slot--by--slot the function @cfunc{log10(cabs(Z)) + I * carg(Z)}
to the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_sqrt (unsigned @var{nslots}, double complex * @var{result}, double complex * @var{operand})
Apply slot--by--slot the function @cfunc{csqrt} to the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_pow (unsigned @var{nslots}, double complex * @var{result}, double complex * @vari{operand}, double complex * @varii{operand})
Apply slot--by--slot the function @cfunc{cpow} to the operands.
@end deftypefun

@c page
@node vectors cplx trigonometric
@subsection Trigonometric complex vector operations


@deftypefun void ccdoubles_cplx_vector_sin (unsigned @var{nslots}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_vector_cos (unsigned @var{nslots}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_vector_tan (unsigned @var{nslots}, double complex * @var{result}, double complex * @var{operand})
Compute slot--by--slot the trigonometric sine, cosine, tangent of the
operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_asin (unsigned @var{nslots}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_vector_acos (unsigned @var{nslots}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_vector_atan (unsigned @var{nslots}, double complex * @var{result}, double complex * @var{operand})
Compute slot--by--slot the trigonometric arc sine, arc cosine, arc
tangent of the operand.
@end deftypefun

@c page
@node vectors cplx hyperbolic
@subsection Hyperbolic complex vector operations


@deftypefun void ccdoubles_cplx_vector_sinh (unsigned @var{nslots}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_vector_cosh (unsigned @var{nslots}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_vector_tanh (unsigned @var{nslots}, double complex * @var{result}, double complex * @var{operand})
Compute slot--by--slot the hyperbolic sine, cosine, tangent of the
operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_asinh (unsigned @var{nslots}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_vector_acosh (unsigned @var{nslots}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_vector_atanh (unsigned @var{nslots}, double complex * @var{result}, double complex * @var{operand})
Compute slot--by--slot the hyperbolic arc sine, arc cosine, arc tangent
of the operand.
@end deftypefun

@c page
@node vectors cplx printing
@subsection Printing cplx vectors


@deftypefun void ccdoubles_cplx_vector_print_display (FILE * @var{f}, const char * @var{name}, unsigned @var{nslots}, double complex * @var{operand})
Print on @var{f} a layout of the operand.  @var{name} must be a pointer
to an @asciiz{} string representing the operand name.  Example:

@example
#define CPLX(REAL,IMAG) (CCDOUBLES_CPLX((REAL),(IMAG)))
#undef NSLOTS
#define NSLOTS          3
double complex	O[NSLOTS] = @{
  CPLX(1.1,-1.1), CPLX(1.2,-1.2), CPLX(1.3,-1.3)
@};
ccdoubles_cplx_vector_print_display(stdout, "O", NSLOTS, O);
@end example

@noindent
will print:

@smallexample
Vector O (dimension 3):
| (1) +1.100000-1.100000i ; (2) +1.200000-1.200000i ; (3) +1.300000-1.300000i |
@end smallexample
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_print_brackets (FILE * @var{f}, unsigned @var{nslots}, double complex * @var{operand})
Print on @var{f} a layout of the operand.  Example:

@example
#define CPLX(REAL,IMAG) (CCDOUBLES_CPLX((REAL),(IMAG)))
#undef NSLOTS
#define NSLOTS          3
double complex      O[NSLOTS] = @{
  CPLX(1.1,-1.1), CPLX(1.2,-1.2), CPLX(1.3,-1.3)
@};
ccdoubles_cplx_vector_print_brackets(stdout, NSLOTS, O);
@end example

@noindent
will print:

@smallexample
[+1.100000-1.100000i +1.200000-1.200000i +1.300000-1.300000i]
@end smallexample
@end deftypefun


@deftypefun void ccdoubles_cplx_vector_print_braces (FILE * @var{f}, unsigned @var{nslots}, double complex * @var{operand})
Print on @var{f} a layout of the operand.  Example:

@example
#define CPLX(REAL,IMAG) (CCDOUBLES_CPLX((REAL),(IMAG)))
#undef NSLOTS
#define NSLOTS          3
double complex      O[NSLOTS] = @{
  CPLX(1.1,-1.1), CPLX(1.2,-1.2), CPLX(1.3,-1.3)
@};
ccdoubles_cplx_vector_print_braces(stdout, NSLOTS, O);
@end example

@noindent
will print:

@smallexample
@{+1.100000-1.100000i, +1.200000-1.200000i, +1.300000-1.300000i@}
@end smallexample
@end deftypefun

@c page
@node vectors int
@section Operations on @code{int}--valued vectors


Vectors of integer numbers are useful because some predicate functions
acting on vectors of @code{double} store the result in an array
integers.

@menu
* vectors int basic::          Basic @code{int} vector operations.
* vectors int printing::       Printing @code{int} vectors.
@end menu

@c page
@node vectors int basic
@subsection Basic @code{int} vector operations


@deftypefun void ccdoubles_int_vector_clear (unsigned @var{nslots}, int * @var{vector})
Reset all the slots to @code{0}.
@end deftypefun


@deftypefun void ccdoubles_int_vector_set (unsigned @var{nslots}, int * @var{vector}, double @var{value})
Set all the slots to the given @var{value}.
@end deftypefun


@deftypefun void ccdoubles_int_vector_copy (unsigned @var{nslots}, int * @var{dst}, int * @var{src})
Copy the slots from @var{src} to @var{dst}.
@end deftypefun

@c page
@node vectors int printing
@subsection Printing @code{int} vectors


@deftypefun void ccdoubles_int_vector_print_display (FILE * @var{f}, const char * @var{name}, unsigned @var{nslots}, int * @var{operand})
Print on @var{f} a layout of the operand.  @var{name} must be a pointer
to an @asciiz{} string representing the operand name.  Example:

@example
#undef NSLOTS
#define NSLOTS          3
int     O[NSLOTS] = @{ 11, 22, 33 @};
ccdoubles_int_vector_print_display(stdout, "O", NSLOTS, O);
@end example

@noindent
will print:

@smallexample
Vector O (dimension 3):
| (1) +11 ; (2) +22 ; (3) +33 |
@end smallexample
@end deftypefun


@deftypefun void ccdoubles_int_vector_print_brackets (FILE * @var{f}, unsigned @var{nslots}, int * @var{operand})
Print on @var{f} a layout of the operand.  Example:

@example
#undef NSLOTS
#define NSLOTS          3
int     O[NSLOTS] = @{ 11, 22, 33 @};
ccdoubles_int_vector_print_brackets(stdout, NSLOTS, O);
@end example

@noindent
will print:

@smallexample
[+11 +22 +33]
@end smallexample
@end deftypefun


@deftypefun void ccdoubles_int_vector_print_braces (FILE * @var{f}, unsigned @var{nslots}, int * @var{operand})
Print on @var{f} a layout of the operand.  Example:

@example
#undef NSLOTS
#define NSLOTS          3
int      O[NSLOTS] = @{ 11, 22, 33 @};
ccdoubles_int_vector_print_brackets(stdout, NSLOTS, O);
@end example

@noindent
will print:

@smallexample
@{+11, +22, +33@}
@end smallexample
@end deftypefun

@c page
@node matrices
@chapter Operations on matrices


@menu
* matrices intro::               Introduction to matrix operations.
* matrices real::                Operations on real--valued matrices.
* matrices cplx::                Operations on complex--valued matrices.
* matrices int::                 Operations on @code{int}--valued matrices.
@end menu

@c page
@node matrices intro
@section Introduction to vector operations


The matrices on which @value{PACKAGE} operates are meant to be
contiguous arrays of @code{double} and @code{double complex} stored in
row--major order, defined as follows:

@example
#include <ccdoubles.h>
#undef NROWS
#undef NCOLS
#define NROWS          2
#define NCOLS          2

double          RM[NROWS][NCOLS] = @{
  @{ 1.2, 3.4 @},  /* this is 1st row */
  @{ 5.6, 7.8 @}   /* this is 2nd row*/
@};
double complex  CM[NROWS][NCOLS] = @{
  @{ CCDOUBLES_CPLX(1.2, 2.3), CCDOUBLES_CPLX(3.4, 4.5) @},
  @{ CCDOUBLES_CPLX(5.6, 6.7), CCDOUBLES_CPLX(7.8, 8.9) @}
@};
@end example

@noindent
or as follows with dynamic size (which forbids hard--coded
initialisation of slots):

@example
unsigned          nrows = 3;
unsigned          ncols = 4;
double          RM[nrows][ncols];
double complex  CM[nrows][ncols];
@end example

All the matrix functions have simple implementation based on the
corresponding vector function; examples for real valued matrices:

@example
void
ccdoubles_real_matrix_add (unsigned nrows, unsigned ncols,
                           double * restrict result,
                           double * restrict operand1,
                           double * restrict operand2)
@{
  ccdoubles_real_vector_add (nrows * ncols, result,
                             operand1, operand2);
@}
void
ccdoubles_real_matrix_sin (unsigned nrows, unsigned ncols,
                           double * restrict result,
                           double * restrict operand)
@{
  ccdoubles_real_vector_sin (nrows * ncols, result, operand);
@}
@end example

@noindent
examples for complex valued matrices:

@example
void
ccdoubles_cplx_matrix_add (unsigned nrows, unsigned ncols,
                           double complex * restrict result,
                           double complex * restrict operand1,
                           double complex * restrict operand2)
@{
  ccdoubles_cplx_vector_add (nrows * ncols,
                             result, operand1, operand2);
@}
void
ccdoubles_cplx_matrix_sin (unsigned nrows, unsigned ncols,
                           double complex * restrict result,
                           double complex * restrict operand)
@{
  ccdoubles_cplx_vector_sin (nrows * ncols, result, operand);
@}
@end example

@value{PACKAGE} functions can be called as follows, see how the arrays
are passed as arguments:

@example
#include <ccdoubles.h>
#undef NROWS
#undef NCOLS
#define NROWS          2
#define NCOLS          2

double  M[NROWS][NCOLS] = @{
  @{ 1.2, 3.4 @},
  @{ 5.6, 7.8 @}
@};
double  R[NROWS][NCOLS];

ccdoubles_real_matrix_sin(NROWS, NCOLS, &R[0][0], &M[0][0]);
@end example

@noindent
the result is stored the array referenced by @code{R}, overwriting the
old contents.

@c page
@node matrices real
@section Operations on real--valued matrices


@menu
* matrices real basic::         Basic real matrix operations.
* matrices real arithmetic::    Arithmetic real matrix operations.
* matrices real rounding::      Rounding real matrix operations.
* matrices real comparison::    Comparing real matrices.
* matrices real predicates::    Inspecting real matrices.
* matrices real special::       Special real matrix operations.
* matrices real explog::        Real matricex exponentiation and
                                logarithms.
* matrices real trigonometric:: Trigonometric real matrix operations.
* matrices real hyperbolic::    Hyperbolic real matrix operations.
* matrices real printing::      Printing real matrices.
@end menu

@c page
@node matrices real basic
@subsection Basic real matrix operations


@deftypefun void ccdoubles_real_matrix_clear (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{matrix})
Reset all the slots to @code{0.0}.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_set (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{matrix}, double @var{value})
Set all the slots to the given @var{value}.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_copy (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{dst}, double * @var{src})
Copy the slots from @var{src} to @var{dst}.
@end deftypefun

@c page
@node matrices real arithmetic
@subsection Arithmetic real matrix operations


@deftypefun void ccdoubles_real_matrix_add (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
@deftypefunx void ccdoubles_real_matrix_sub (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
@deftypefunx void ccdoubles_real_matrix_mul (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
@deftypefunx void ccdoubles_real_matrix_div (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
Perform slot--by--slot addition, subtraction, multiplication and
division.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_neg (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double * @var{operand})
Perform the slot--by--slot negation of the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_abs (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double * @var{operand})
Compute slot--by--slot the absolute value of the operand.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void ccdoubles_real_matrix_fmod (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
Apply slot--by--slot the function @cfunc{fmod} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_drem (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
Apply slot--by--slot the function @cfunc{drem} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_remainder (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double * @vari{operand}, double *1 @varii{operand})
Apply slot--by--slot the function @cfunc{remainder} to the operands.
@end deftypefun

@c page
@node matrices real rounding
@subsection Rounding real matrix operations


@deftypefun void ccdoubles_real_matrix_ceil (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{ceil}.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_floor (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{floor}.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_trunc (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{trunc}.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_round (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{round}.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_rint (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{rint}.
@end deftypefun

@c page
@node matrices real comparison
@subsection Comparing real matrices


@deftypefun void ccdoubles_real_matrix_isgreater (unsigned @var{nrows}, unsigned @var{ncols}, int * @var{result}, double * @vari{operand}, double * @varii{operand})
Apply slot--by--slot the function @cfunc{isgreater} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_isgreaterequal (unsigned @var{nrows}, unsigned @var{ncols}, int * @var{result}, double * @vari{operand}, double * @varii{operand})
Apply slot--by--slot the function @cfunc{isgreaterequal} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_isless (unsigned @var{nrows}, unsigned @var{ncols}, int * @var{result}, double * @vari{operand}, double * @varii{operand})
Apply slot--by--slot the function @cfunc{isless} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_islessequal (unsigned @var{nrows}, unsigned @var{ncols}, int * @var{result}, double * @vari{operand}, double * @varii{operand})
Apply slot--by--slot the function @cfunc{islessequal} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_islessgreater (unsigned @var{nrows}, unsigned @var{ncols}, int * @var{result}, double * @vari{operand}, double * @varii{operand})
Apply slot--by--slot the function @cfunc{islessgreater} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_isunordered (unsigned @var{nrows}, unsigned @var{ncols}, int * @var{result}, double * @vari{operand}, double * @varii{operand})
Apply slot--by--slot the function @cfunc{isunordered} to the operands.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void ccdoubles_real_matrix_min (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
Apply slot--by--slot the function @cfunc{fmin} to the operands.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_max (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
Apply slot--by--slot the function @cfunc{fmax} to the operands.
@end deftypefun

@c page
@node matrices real predicates
@subsection Inspecting real matrices


@deftypefun void ccdoubles_real_matrix_fpclassify (unsigned @var{nrows}, unsigned @var{ncols}, int * @var{result}, double * @var{operand})
Apply slot--by--slot the macro @cfunc{fpclassify} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_isfinite (unsigned @var{nrows}, unsigned @var{ncols}, int * @var{result}, double * @var{operand})
Apply slot--by--slot the macro @cfunc{isfinite} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_isinfinite (unsigned @var{nrows}, unsigned @var{ncols}, int * @var{result}, double * @var{operand})
Apply slot--by--slot the macro @cfunc{isfinite} to the operand and
reverse the result.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_isnormal (unsigned @var{nrows}, unsigned @var{ncols}, int * @var{result}, double * @var{operand})
Apply slot--by--slot the macro @cfunc{isnormal} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_isnan (unsigned @var{nrows}, unsigned @var{ncols}, int * @var{result}, double * @var{operand})
Apply slot--by--slot the macro @cfunc{isnan} to the operand.
@end deftypefun

@c page
@node matrices real special
@subsection Special real matrix operations


@deftypefun void ccdoubles_real_matrix_scalar_mul (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double @var{lambda}, const double * @var{operand})
Multiply the scalar @var{lambda} with all the slots in the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_linear_combination (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double @var{alpha}, double * @vari{operand}, double @var{beta}, double * @varii{operand})
Perform the linear combination of the matrix operands and the given
scalars.  The implementation is equivalent to:

@example
for (unsigned i=0; i<nrows; ++i) @{
  for (unsigned j=0; j<ncols; ++j) @{
    result[i][j] = \
      alpha * operand1[i][j] + \
      beta  * operand2[i][j];
  @}
@}
@end example
@end deftypefun


@deftypefun void ccdoubles_real_matrix_transpose (unsigned @var{operand_nrows}, unsigned @var{operand_ncols}, double * @var{result}, double * @var{operand})
Transpose the operand.  If @var{result} and @var{operand} reference the
same array: the result is undefined.  To call this function we are meant
to do:

@example
double  O[2][3];
double  R[3][2];
ccdoubles_real_matrix_transpose (2, 3, &R[0][0], &O[0][0]);
@end example
@end deftypefun


@deftypefun void ccdoubles_real_matrix_rowcol_mul (unsigned @var{result_nrows}, unsigned @var{operand_n}, unsigned @var{result_ncols}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
Compute the row--column product between the operands.  To call this
function we are meant to do:

@example
double     R[result_nrows][result_ncols];
double     O1[result_nrows][operand_n];
double     O2[operand_n][result_ncols];
ccdoubles_real_matrix_rowcol_mul \
  (result_nrows, operand_n, result_ncols,
   &R[0][0], &O1[0][0], &O2[0][0]);
@end example

When possible, rather than this function, we should consider using
@acronym{CBLAS}'s @cfunc{cblas_dgemm}.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_linspace (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double @var{start}, double @var{row_past}, double @var{col_past})
Fill the result matrix with @var{nrows} times @var{ncols} evenly--spaced
steps from @var{start} to @var{row_past} in the horizontal direction and
from @var{start} to @var{col_past} in the vertical direction.  It is
implemented as follows:

@example
double        row_step = (row_past - start) / ((double)nrows);
double        col_step = (col_past - start) / ((double)ncols);
for (unsigned i=0; i<nrows; ++i) @{
  double      row_first = ((double)i) * row_step + start;
  for (unsigned j=0; j<ncols; ++j) @{
    result[i * ncols + j] = ((double)j) * col_step + row_first;
  @}
@}
@end example

As example, the code:

@example
unsigned    nrows = 10;
unsigned    ncols = 10;
double      R[nrows][ncols];
double      start    = 0.0;
double      row_past = 10.0;
double      col_past = 10.0;
ccdoubles_real_matrix_linspace (nrows, ncols, &R[0][0],
                                start, row_past, col_past);
ccdoubles_real_matrix_print_brackets(stdout, nrows, ncols,
                                     &R[0][0]);
@end example

@noindent
prints (edited to remove trailing zeros):

@example
[[+0.0 +1.0 +2.0 +3.0 +4.0 +5.0 +6.0 +7.0 +8.0 +9.0]
 [+1.0 +2.0 +3.0 +4.0 +5.0 +6.0 +7.0 +8.0 +9.0 +10.0]
 [+2.0 +3.0 +4.0 +5.0 +6.0 +7.0 +8.0 +9.0 +10.0 +11.0]
 [+3.0 +4.0 +5.0 +6.0 +7.0 +8.0 +9.0 +10.0 +11.0 +12.0]
 [+4.0 +5.0 +6.0 +7.0 +8.0 +9.0 +10.0 +11.0 +12.0 +13.0]
 [+5.0 +6.0 +7.0 +8.0 +9.0 +10.0 +11.0 +12.0 +13.0 +14.0]
 [+6.0 +7.0 +8.0 +9.0 +10.0 +11.0 +12.0 +13.0 +14.0 +15.0]
 [+7.0 +8.0 +9.0 +10.0 +11.0 +12.0 +13.0 +14.0 +15.0 +16.0]
 [+8.0 +9.0 +10.0 +11.0 +12.0 +13.0 +14.0 +15.0 +16.0 +17.0]
 [+9.0 +10.0 +11.0 +12.0 +13.0 +14.0 +15.0 +16.0 +17.0 +18.0]]
@end example
@end deftypefun

@c page
@node matrices real explog
@subsection Real matrices exponentiation and logarithms


@deftypefun void ccdoubles_real_matrix_exp (unsigned @var{ncols}, unsigned @var{nrows}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{exp} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_exp10 (unsigned @var{ncols}, unsigned @var{nrows}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @code{exp(X * log(10))} to the
operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_exp2 (unsigned @var{ncols}, unsigned @var{nrows}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{exp2} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_log (unsigned @var{ncols}, unsigned @var{nrows}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{log} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_log10 (unsigned @var{ncols}, unsigned @var{nrows}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{log10} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_log2 (unsigned @var{ncols}, unsigned @var{nrows}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{log2} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_logb (unsigned @var{ncols}, unsigned @var{nrows}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{logb} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_pow (unsigned @var{ncols}, unsigned @var{nrows}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
Apply slot--by--slot the function @cfunc{pow} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_sqrt (unsigned @var{ncols}, unsigned @var{nrows}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{sqrt} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_cbrt (unsigned @var{ncols}, unsigned @var{nrows}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{cbrt} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_hypot (unsigned @var{ncols}, unsigned @var{nrows}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
Apply slot--by--slot the function @cfunc{hypot} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_expm1 (unsigned @var{ncols}, unsigned @var{nrows}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{expm1} to the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_log1p (unsigned @var{ncols}, unsigned @var{nrows}, double * @var{result}, double * @var{operand})
Apply slot--by--slot the function @cfunc{log1p} to the operand.
@end deftypefun

@c page
@node matrices real trigonometric
@subsection Trigonometric real matrix operations


@deftypefun void ccdoubles_real_matrix_sin (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_matrix_cos (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_matrix_tan (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double * @var{operand})
Compute slot--by--slot the trigonometric sine, cosine, tangent of the
operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_asin (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_matrix_acos (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_matrix_atan (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double * @var{operand})
Compute slot--by--slot the trigonometric arc sine, arc cosine, arc
tangent of the operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_atan2 (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double * @vari{operand}, double * @varii{operand})
Compute slot--by--slot the trigonometric arc tangent of the operands.
The implementation is equivalent to:

@example
for (unsigned i=0; i<nrows; ++i) @{
  for (unsigned j=0; i<ncols; ++j) @{
    result[i][j] = atan2(operand1[i][j], operand2[i][j]);
  @}
@}
@end example

@glibcref{Inverse Trig Functions, atan2} for details on @cfunc{atan2}.
@end deftypefun

@c page
@node matrices real hyperbolic
@subsection Hyperbolic real matrix operations


@deftypefun void ccdoubles_real_matrix_sinh (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_matrix_cosh (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_matrix_tanh (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double * @var{operand})
Compute slot--by--slot the hyperbolic sine, cosine, tangent of the
operand.
@end deftypefun


@deftypefun void ccdoubles_real_matrix_asinh (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_matrix_acosh (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double * @var{operand})
@deftypefunx void ccdoubles_real_matrix_atanh (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double * @var{operand})
Compute slot--by--slot the hyperbolic arc sine, arc cosine, arc tangent
of the operand.
@end deftypefun

@c page
@node matrices real printing
@subsection Printing real matrices


@deftypefun void ccdoubles_real_matrix_print_display (FILE * @var{f}, const char * @var{name}, unsigned @var{nrows}, unsigned @var{ncols}, double * @var{operand})
Print on @var{f} a layout of the operand.  @var{name} must be a pointer
to an @asciiz{} string representing the operand name.  Example:

@example
#undef NROWS
#undef NCOLS
#define NROWS           2
#define NCOLS           3
double      O[NROWS][NCOLS] = @{
  @{ 1.1, 1.2, 1.3 @},
  @{ 2.1, 2.2, 2.3 @}
@};
ccdoubles_real_matrix_print_display \
  (stdout, "O", NROWS, NCOLS, &O[0][0]);
@end example

@noindent
will print:

@smallexample
Row-major matrix O (dimension 2 x 3) (displayed in row-major order):
| (1,1) +1.100000 ; (1,2) +1.200000 ; (1,3) +1.300000  |
| (2,1) +2.100000 ; (2,2) +2.200000 ; (2,3) +2.300000  |
@end smallexample
@end deftypefun


@deftypefun void ccdoubles_real_matrix_print_brackets (FILE * @var{f}, unsigned @var{nrows}, unsigned @var{ncols}, double * @var{operand})
Print on @var{f} a layout of the operand.  Example:

@example
#undef NROWS
#undef NCOLS
#define NROWS           2
#define NCOLS           3
double      O[NROWS][NCOLS] = @{
  @{ 1.1, 1.2, 1.3 @},
  @{ 2.1, 2.2, 2.3 @}
@};
ccdoubles_real_matrix_print_brackets \
  (stdout, NROWS, NCOLS, &O[0][0]);
@end example

@noindent
will print:

@smallexample
[[+1.100000 +1.200000 +1.300000]
 [+2.100000 +2.200000 +2.300000]]
@end smallexample
@end deftypefun


@deftypefun void ccdoubles_real_matrix_print_braces (FILE * @var{f}, unsigned @var{nrows}, unsigned @var{ncols}, double * @var{operand})
Print on @var{f} a layout of the operand.  Example:

@example
#undef NROWS
#undef NCOLS
#define NROWS           2
#define NCOLS           3
double      O[NROWS][NCOLS] = @{
  @{ 1.1, 1.2, 1.3 @},
  @{ 2.1, 2.2, 2.3 @}
@};
ccdoubles_real_matrix_print_braces \
  (stdout, NROWS, NCOLS, &O[0][0]);
@end example

@noindent
will print:

@smallexample
@{@{+1.100000, +1.200000, +1.300000@},
 @{+2.100000, +2.200000, +2.300000@}@}
@end smallexample
@end deftypefun

@c page
@node matrices cplx
@section Operations on complex--valued matrices


@menu
* matrices cplx basic::         Basic complex matrix operations.
* matrices cplx arithmetic::    Arithmetic complex matrix operations.
* matrices cplx special::       Special complex matrix operations.
* matrices cplx explog::        Complex matrices exponentiation and
                                logarithms.
* matrices cplx trigonometric:: Trigonometric complex matrix operations.
* matrices cplx hyperbolic::    Hyperbolic complex matrix operations.
* matrices cplx printing::      Printing complex matrices.
@end menu

@c page
@node matrices cplx basic
@subsection Basic complex matrix operations


@deftypefun void ccdoubles_cplx_matrix_clear (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{matrix})
Reset all the slots to complex numbers with real part @code{0.0} and
complex part @code{0.0}.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_set (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{matrix}, double complex @var{value})
Set all the slots to the given @var{value}.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_set_split (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{vector}, double @var{value_re}, double @var{value_im})
Set all the slots to a complex number having @var{value_re} as real part
and @var{value_im} as imaginary part.  This function is like
@cfunc{ccdoubles_cplx_matrix_set}, but splitting the real and imaginary
parts makes it easier to interface it with foreign languages.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_copy (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{dst}, double complex * @var{src})
Copy the slots from @var{src} to @var{dst}.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun void ccdoubles_cplx_matrix_real (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double complex * @var{operand})
Extract slot--by--slot the real part of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_imag (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double complex * @var{operand})
Extract slot--by--slot the imaginary part of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_magnitude (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double complex * @var{operand})
Extract slot--by--slot the magnitude of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_angle (unsigned @var{nrows}, unsigned @var{ncols}, double * @var{result}, double complex * @var{operand})
Extract slot--by--slot the angle of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_conj (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{result}, double complex * @var{operand})
Compute slot--by--slot the conjugate of the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_from_rect (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{result}, double * @var{real}, double * imag)
Build slot--by--slot a complex valued matrix from the real and imaginary
parts.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_from_polar (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{result}, double * @var{magnitude}, double * @var{angle})
Build slot--by--slot a complex valued matrix from the magnitude and
angle.
@end deftypefun

@c page
@node matrices cplx arithmetic
@subsection Arithmetic complex matrix operations


@deftypefun void ccdoubles_cplx_matrix_add (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{result}, double complex * @vari{operand}, double complex * @varii{operand})
@deftypefunx void ccdoubles_cplx_matrix_sub (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{result}, double complex * @vari{operand}, double complex * @varii{operand})
@deftypefunx void ccdoubles_cplx_matrix_mul (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{result}, double complex * @vari{operand}, double complex * @varii{operand})
@deftypefunx void ccdoubles_cplx_matrix_div (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{result}, double complex * @vari{operand}, double complex * @varii{operand})
Perform slot--by--slot addition, subtraction, multiplication and
division.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_neg (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{result}, double complex * @var{operand})
Perform the slot--by--slot negation of the operand.
@end deftypefun

@c page
@node matrices cplx special
@subsection Special complex matrix operations


@deftypefun void ccdoubles_cplx_matrix_scalar_mul (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{result}, double complex  @var{lambda}, const double complex * @var{operand})
Multiply the scalar @var{lambda} with all the slots in the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_scalar_mul_split (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{result}, double @var{lambda_re}, double @var{lambda_im}, const double complex * @var{operand})
Multiply the scalar having real part @var{lambda_re} and imaginary part
@var{lambda_im} with all the slots in the operand.  This function is
like @cfunc{ccdoubles_cplx_matrix_scalar_mul}, but splitting the real
and imaginary parts of the coefficient makes it easier to interface it
with foreign languages.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_linear_combination (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{result}, double complex @var{alpha}, double complex * @vari{operand}, double complex @var{beta}, double complex * @varii{operand})
Perform the linear combination of the matrix operands and the given
scalars.  The implementation is equivalent to:

@example
for (unsigned i=0; i<nrows; ++i) @{
  for (unsigned j=0; j<ncols; ++j) @{
    result[i][j] = \
      alpha * operand1[i][j] + \
      beta  * operand2[i][j];
  @}
@}
@end example
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_linear_combination_split (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{result}, double @var{alpha_re}, double @var{alpha_im}, double complex * @vari{operand}, double @var{beta_re}, double @var{beta_im}, double complex * @varii{operand})
Perform the linear combination of the matrix operands and the given
scalars.  This function is like
@cfunc{ccdoubles_cplx_matrix_linear_combination}, but splitting the real
and imaginary parts of the coefficient makes it easier to interface it
with foreign languages.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_transpose (unsigned @var{operand_nrows}, unsigned @var{operand_ncols}, double complex * @var{result}, double complex * @var{operand})
Transpose the operand.  If @var{result} and @var{operand} reference the
same array: the result is undefined.  To call this function we are meant
to do:

@example
double complex  O[2][3];
double complex  R[3][2];
ccdoubles_real_matrix_transpose (2, 3, &R[0][0], &O[0][0]);
@end example
@end deftypefun


@deftypefun void ccdoubles_real_matrix_conjugate_transpose (unsigned @var{operand_nrows}, unsigned @var{operand_ncols}, double * @var{result}, double * @var{operand})
Transpose the operand and conjugate its elements.  If @var{result} and
@var{operand} reference the same array: the result is undefined.  To
call this function we are meant to do:

@example
double  O[2][3];
double  R[3][2];
ccdoubles_real_matrix_conjugate_transpose \
  (2, 3, &R[0][0], &O[0][0]);
@end example
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_rowcol_mul (unsigned @var{result_nrows}, unsigned @var{operand_n}, unsigned @var{result_ncols}, double complex * @var{result}, double complex * @vari{operand}, double complex * @varii{operand})
Compute the row--column product between the operands.  To call this
function we are meant to do:

@example
double     R[result_nrows][result_ncols];
double     O1[result_nrows][operand_n];
double     O2[operand_n][result_ncols];
ccdoubles_real_matrix_rowcol_mul \
  (result_nrows, operand_n, result_ncols,
   &R[0][0], &O1[0][0], &O2[0][0]);
@end example

When possible, rather than this function, we should consider using
@acronym{CBLAS}'s @cfunc{cblas_zgemm}.
@end deftypefun

@c page
@node matrices cplx explog
@subsection Complex matrices exponentiation and logarithms


@deftypefun void ccdoubles_cplx_matrix_exp (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{result}, double complex * @var{operand})
Apply slot--by--slot the function @cfunc{cexp} to the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_log (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{result}, double complex * @var{operand})
Apply slot--by--slot the function @cfunc{clog} to the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_log10 (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{result}, double complex * @var{operand})
Apply slot--by--slot the function @cfunc{log10(cabs(Z)) + I * carg(Z)}
to the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_sqrt (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{result}, double complex * @var{operand})
Apply slot--by--slot the function @cfunc{csqrt} to the operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_pow (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{result}, double complex * @vari{operand}, double complex * @varii{operand})
Apply slot--by--slot the function @cfunc{cpow} to the operands.
@end deftypefun

@c page
@node matrices cplx trigonometric
@subsection Trigonometric complex matrix operations


@deftypefun void ccdoubles_cplx_matrix_sin (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_matrix_cos (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_matrix_tan (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{result}, double complex * @var{operand})
Compute slot--by--slot the trigonometric sine, cosine, tangent of the
operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_asin (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_matrix_acos (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_matrix_atan (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{result}, double complex * @var{operand})
Compute slot--by--slot the trigonometric arc sine, arc cosine, arc
tangent of the operand.
@end deftypefun

@c page
@node matrices cplx hyperbolic
@subsection Hyperbolic complex matrix operations


@deftypefun void ccdoubles_cplx_matrix_sinh (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_matrix_cosh (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_matrix_tanh (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{result}, double complex * @var{operand})
Compute slot--by--slot the hyperbolic sine, cosine, tangent of the
operand.
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_asinh (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_matrix_acosh (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{result}, double complex * @var{operand})
@deftypefunx void ccdoubles_cplx_matrix_atanh (unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{result}, double complex * @var{operand})
Compute slot--by--slot the hyperbolic arc sine, arc cosine, arc tangent
of the operand.
@end deftypefun

@c page
@node matrices cplx printing
@subsection Printing complex matrices


@deftypefun void ccdoubles_real_matrix_print_display (FILE * @var{f}, const char * @var{name}, unsigned @var{nrows}, unsigned @var{ncols}, double * @var{operand})
Print on @var{f} a layout of the operand.  @var{name} must be a pointer
to an @asciiz{} string representing the operand name.  Example:

@example
#define CPLX(REAL,IMAG)  CCDOUBLES_CPLX((REAL),(IMAG))
#undef NROWS
#undef NCOLS
#define NROWS           2
#define NCOLS           3
double complex  O[NROWS][NCOLS] = @{
  @{ CPLX(1.1,-1.1), CPLX(1.2,-1.2), CPLX(1.3,-1.3) @},
  @{ CPLX(2.1,-2.1), CPLX(2.2,-2.2), CPLX(2.3,-2.3) @}
@};
ccdoubles_cplx_matrix_print_display \
  (stdout, "O", NROWS, NCOLS, &O[0][0]);
@end example

@noindent
will print:

@smallexample
Row-major matrix O (dimension 2 x 3) (displayed in row-major order):
| (1,1) +1.100000-1.100000i ; (1,2) +1.200000-1.200000i ; (1,3) +1.300000-1.300000i  |
| (2,1) +2.100000-2.100000i ; (2,2) +2.200000-2.200000i ; (2,3) +2.300000-2.300000i  |
@end smallexample
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_print_brackets (FILE * @var{f}, unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{operand})
Print on @var{f} a layout of the operand.  Example:

@example
#define CPLX(REAL,IMAG)  CCDOUBLES_CPLX((REAL),(IMAG))
#undef NROWS
#undef NCOLS
#define NROWS           2
#define NCOLS           3
double complex  O[NROWS][NCOLS] = @{
  @{ CPLX(1.1,-1.1), CPLX(1.2,-1.2), CPLX(1.3,-1.3) @},
  @{ CPLX(2.1,-2.1), CPLX(2.2,-2.2), CPLX(2.3,-2.3) @}
@};
ccdoubles_cplx_matrix_print_brackets \
  (stdout, NROWS, NCOLS, &O[0][0]);
@end example

@noindent
will print:

@smallexample
[[+1.100000-1.100000i +1.200000-1.200000i +1.300000-1.300000i]
 [+2.100000-2.100000i +2.200000-2.200000i +2.300000-2.300000i]]
@end smallexample
@end deftypefun


@deftypefun void ccdoubles_cplx_matrix_print_braces (FILE * @var{f}, unsigned @var{nrows}, unsigned @var{ncols}, double complex * @var{operand})
Print on @var{f} a layout of the operand.  Example:

@example
#define CPLX(REAL,IMAG)  CCDOUBLES_CPLX((REAL),(IMAG))
#undef NROWS
#undef NCOLS
#define NROWS           2
#define NCOLS           3
double complex  O[NROWS][NCOLS] = @{
  @{ CPLX(1.1,-1.1), CPLX(1.2,-1.2), CPLX(1.3,-1.3) @},
  @{ CPLX(2.1,-2.1), CPLX(2.2,-2.2), CPLX(2.3,-2.3) @}
@};
ccdoubles_cplx_matrix_print_braces \
  (stdout, NROWS, NCOLS, &O[0][0]);
@end example

@noindent
will print:

@smallexample
@{@{+1.100000-1.100000i, +1.200000-1.200000i, +1.300000-1.300000i@},
 @{+2.100000-2.100000i, +2.200000-2.200000i, +2.300000-2.300000i@}@}
@end smallexample
@end deftypefun

@c page
@node matrices int
@section Operations on @code{int}--valued matrices


Matrices of integer numbers are useful because some predicate functions
acting on matrices of @code{double} store the result in an array
integers.

@menu
* matrices int basic::          Basic @code{int} vector operations.
* matrices int printing::       Printing @code{int} vectors.
@end menu

@c page
@node matrices int basic
@subsection Basic @code{int} vector operations


@deftypefun void ccdoubles_int_matrix_clear (unsigned @var{nrows}, unsigned @var{ncols}, int * @var{matrix})
Reset all the slots to @code{0}.
@end deftypefun


@deftypefun void ccdoubles_int_matrix_set (unsigned @var{nrows}, unsigned @var{ncols}, int * @var{matrix}, double @var{value})
Set all the slots to the given @var{value}.
@end deftypefun


@deftypefun void ccdoubles_int_matrix_copy (unsigned @var{nrows}, unsigned @var{ncols}, int * @var{dst}, int * @var{src})
Copy the slots from @var{src} to @var{dst}.
@end deftypefun

@c page
@node matrices int printing
@subsection Printing @code{int} vectors


@deftypefun void ccdoubles_int_matrix_print_display (FILE * @var{f}, const char * @var{name}, unsigned @var{nrows}, unsigned @var{ncols}, int * @var{operand})
Print on @var{f} a layout of the operand.  @var{name} must be a pointer
to an @asciiz{} string representing the operand name.  Example:

@example
#undef NROWS
#undef NCOLS
#define NROWS           2
#define NCOLS           3
int     O[NROWS][NCOLS] = @{
  @{ 11, 22, 33 @},
  @{ 44, 55, 66 @}
@};
ccdoubles_int_matrix_print_display \
  (stdout, "O", NROWS, NCOLS, &O[0][0]);
@end example

@noindent
will print:

@smallexample
Row-major matrix O (dimension 2 x 3) (displayed in row-major order):
| (1,1) +11 ; (1,2) +22 ; (1,3) +33 |
| (2,1) +44 ; (2,2) +55 ; (2,3) +66 |
@end smallexample
@end deftypefun


@deftypefun void ccdoubles_int_matrix_print_brackets (FILE * @var{f}, unsigned @var{nrows}, unsigned @var{ncols}, int * @var{operand})
Print on @var{f} a layout of the operand.  Example:

@example
#undef NROWS
#undef NCOLS
#define NROWS           2
#define NCOLS           3
int     O[NROWS][NCOLS] = @{
  @{ 11, 22, 33 @},
  @{ 44, 55, 66 @}
@};
ccdoubles_int_matrix_print_brackets \
  (stdout, NROWS, NCOLS, &O[0][0]);
@end example

@noindent
will print:

@smallexample
[[+11 +22 +33]
 [+44 +55 +66]]
@end smallexample
@end deftypefun


@deftypefun void ccdoubles_int_matrix_print_braces (FILE * @var{f}, unsigned @var{nrows}, unsigned @var{ncols}, int * @var{operand})
Print on @var{f} a layout of the operand.  Example:

@example
#undef NROWS
#undef NCOLS
#define NROWS           2
#define NCOLS           3
int     O[NROWS][NCOLS] = @{
  @{ 11, 22, 33 @},
  @{ 44, 55, 66 @}
@};
ccdoubles_int_matrix_print_braces \
  (stdout, NROWS, NCOLS, &O[0][0]);
@end example

@noindent
will print:

@smallexample
@{@{+11, +22, +33@},
 @{+44, +55, +66@}@}
@end smallexample
@end deftypefun

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include gpl-3.0.texi
@include fdl-1.3.texi

@c page
@node resources
@appendix On--line resources


The latest version of this package can be downloaded from:

@center @url{http://github.com/marcomaggi/@value{PACKAGE_NICKNAME}/}

@noindent
the documentation is available online:

@center @url{http://marcomaggi.github.com/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@node references
@appendix Bibliography and references



@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

